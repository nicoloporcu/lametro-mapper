// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gtfs-realtime.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_gtfs_2drealtime_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_gtfs_2drealtime_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_gtfs_2drealtime_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_gtfs_2drealtime_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_gtfs_2drealtime_2eproto;
namespace transit_realtime {
class Alert;
struct AlertDefaultTypeInternal;
extern AlertDefaultTypeInternal _Alert_default_instance_;
class EntitySelector;
struct EntitySelectorDefaultTypeInternal;
extern EntitySelectorDefaultTypeInternal _EntitySelector_default_instance_;
class FeedEntity;
struct FeedEntityDefaultTypeInternal;
extern FeedEntityDefaultTypeInternal _FeedEntity_default_instance_;
class FeedHeader;
struct FeedHeaderDefaultTypeInternal;
extern FeedHeaderDefaultTypeInternal _FeedHeader_default_instance_;
class FeedMessage;
struct FeedMessageDefaultTypeInternal;
extern FeedMessageDefaultTypeInternal _FeedMessage_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class Shape;
struct ShapeDefaultTypeInternal;
extern ShapeDefaultTypeInternal _Shape_default_instance_;
class TimeRange;
struct TimeRangeDefaultTypeInternal;
extern TimeRangeDefaultTypeInternal _TimeRange_default_instance_;
class TranslatedImage;
struct TranslatedImageDefaultTypeInternal;
extern TranslatedImageDefaultTypeInternal _TranslatedImage_default_instance_;
class TranslatedImage_LocalizedImage;
struct TranslatedImage_LocalizedImageDefaultTypeInternal;
extern TranslatedImage_LocalizedImageDefaultTypeInternal _TranslatedImage_LocalizedImage_default_instance_;
class TranslatedString;
struct TranslatedStringDefaultTypeInternal;
extern TranslatedStringDefaultTypeInternal _TranslatedString_default_instance_;
class TranslatedString_Translation;
struct TranslatedString_TranslationDefaultTypeInternal;
extern TranslatedString_TranslationDefaultTypeInternal _TranslatedString_Translation_default_instance_;
class TripDescriptor;
struct TripDescriptorDefaultTypeInternal;
extern TripDescriptorDefaultTypeInternal _TripDescriptor_default_instance_;
class TripUpdate;
struct TripUpdateDefaultTypeInternal;
extern TripUpdateDefaultTypeInternal _TripUpdate_default_instance_;
class TripUpdate_StopTimeEvent;
struct TripUpdate_StopTimeEventDefaultTypeInternal;
extern TripUpdate_StopTimeEventDefaultTypeInternal _TripUpdate_StopTimeEvent_default_instance_;
class TripUpdate_StopTimeUpdate;
struct TripUpdate_StopTimeUpdateDefaultTypeInternal;
extern TripUpdate_StopTimeUpdateDefaultTypeInternal _TripUpdate_StopTimeUpdate_default_instance_;
class TripUpdate_StopTimeUpdate_StopTimeProperties;
struct TripUpdate_StopTimeUpdate_StopTimePropertiesDefaultTypeInternal;
extern TripUpdate_StopTimeUpdate_StopTimePropertiesDefaultTypeInternal _TripUpdate_StopTimeUpdate_StopTimeProperties_default_instance_;
class TripUpdate_TripProperties;
struct TripUpdate_TripPropertiesDefaultTypeInternal;
extern TripUpdate_TripPropertiesDefaultTypeInternal _TripUpdate_TripProperties_default_instance_;
class VehicleDescriptor;
struct VehicleDescriptorDefaultTypeInternal;
extern VehicleDescriptorDefaultTypeInternal _VehicleDescriptor_default_instance_;
class VehiclePosition;
struct VehiclePositionDefaultTypeInternal;
extern VehiclePositionDefaultTypeInternal _VehiclePosition_default_instance_;
class VehiclePosition_CarriageDetails;
struct VehiclePosition_CarriageDetailsDefaultTypeInternal;
extern VehiclePosition_CarriageDetailsDefaultTypeInternal _VehiclePosition_CarriageDetails_default_instance_;
}  // namespace transit_realtime
PROTOBUF_NAMESPACE_OPEN
template<> ::transit_realtime::Alert* Arena::CreateMaybeMessage<::transit_realtime::Alert>(Arena*);
template<> ::transit_realtime::EntitySelector* Arena::CreateMaybeMessage<::transit_realtime::EntitySelector>(Arena*);
template<> ::transit_realtime::FeedEntity* Arena::CreateMaybeMessage<::transit_realtime::FeedEntity>(Arena*);
template<> ::transit_realtime::FeedHeader* Arena::CreateMaybeMessage<::transit_realtime::FeedHeader>(Arena*);
template<> ::transit_realtime::FeedMessage* Arena::CreateMaybeMessage<::transit_realtime::FeedMessage>(Arena*);
template<> ::transit_realtime::Position* Arena::CreateMaybeMessage<::transit_realtime::Position>(Arena*);
template<> ::transit_realtime::Shape* Arena::CreateMaybeMessage<::transit_realtime::Shape>(Arena*);
template<> ::transit_realtime::TimeRange* Arena::CreateMaybeMessage<::transit_realtime::TimeRange>(Arena*);
template<> ::transit_realtime::TranslatedImage* Arena::CreateMaybeMessage<::transit_realtime::TranslatedImage>(Arena*);
template<> ::transit_realtime::TranslatedImage_LocalizedImage* Arena::CreateMaybeMessage<::transit_realtime::TranslatedImage_LocalizedImage>(Arena*);
template<> ::transit_realtime::TranslatedString* Arena::CreateMaybeMessage<::transit_realtime::TranslatedString>(Arena*);
template<> ::transit_realtime::TranslatedString_Translation* Arena::CreateMaybeMessage<::transit_realtime::TranslatedString_Translation>(Arena*);
template<> ::transit_realtime::TripDescriptor* Arena::CreateMaybeMessage<::transit_realtime::TripDescriptor>(Arena*);
template<> ::transit_realtime::TripUpdate* Arena::CreateMaybeMessage<::transit_realtime::TripUpdate>(Arena*);
template<> ::transit_realtime::TripUpdate_StopTimeEvent* Arena::CreateMaybeMessage<::transit_realtime::TripUpdate_StopTimeEvent>(Arena*);
template<> ::transit_realtime::TripUpdate_StopTimeUpdate* Arena::CreateMaybeMessage<::transit_realtime::TripUpdate_StopTimeUpdate>(Arena*);
template<> ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* Arena::CreateMaybeMessage<::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties>(Arena*);
template<> ::transit_realtime::TripUpdate_TripProperties* Arena::CreateMaybeMessage<::transit_realtime::TripUpdate_TripProperties>(Arena*);
template<> ::transit_realtime::VehicleDescriptor* Arena::CreateMaybeMessage<::transit_realtime::VehicleDescriptor>(Arena*);
template<> ::transit_realtime::VehiclePosition* Arena::CreateMaybeMessage<::transit_realtime::VehiclePosition>(Arena*);
template<> ::transit_realtime::VehiclePosition_CarriageDetails* Arena::CreateMaybeMessage<::transit_realtime::VehiclePosition_CarriageDetails>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace transit_realtime {

enum FeedHeader_Incrementality : int {
  FeedHeader_Incrementality_FULL_DATASET = 0,
  FeedHeader_Incrementality_DIFFERENTIAL = 1
};
bool FeedHeader_Incrementality_IsValid(int value);
constexpr FeedHeader_Incrementality FeedHeader_Incrementality_Incrementality_MIN = FeedHeader_Incrementality_FULL_DATASET;
constexpr FeedHeader_Incrementality FeedHeader_Incrementality_Incrementality_MAX = FeedHeader_Incrementality_DIFFERENTIAL;
constexpr int FeedHeader_Incrementality_Incrementality_ARRAYSIZE = FeedHeader_Incrementality_Incrementality_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FeedHeader_Incrementality_descriptor();
template<typename T>
inline const std::string& FeedHeader_Incrementality_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FeedHeader_Incrementality>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FeedHeader_Incrementality_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FeedHeader_Incrementality_descriptor(), enum_t_value);
}
inline bool FeedHeader_Incrementality_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FeedHeader_Incrementality* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FeedHeader_Incrementality>(
    FeedHeader_Incrementality_descriptor(), name, value);
}
enum TripUpdate_StopTimeUpdate_ScheduleRelationship : int {
  TripUpdate_StopTimeUpdate_ScheduleRelationship_SCHEDULED = 0,
  TripUpdate_StopTimeUpdate_ScheduleRelationship_SKIPPED = 1,
  TripUpdate_StopTimeUpdate_ScheduleRelationship_NO_DATA = 2,
  TripUpdate_StopTimeUpdate_ScheduleRelationship_UNSCHEDULED = 3
};
bool TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValid(int value);
constexpr TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MIN = TripUpdate_StopTimeUpdate_ScheduleRelationship_SCHEDULED;
constexpr TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MAX = TripUpdate_StopTimeUpdate_ScheduleRelationship_UNSCHEDULED;
constexpr int TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE = TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor();
template<typename T>
inline const std::string& TripUpdate_StopTimeUpdate_ScheduleRelationship_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TripUpdate_StopTimeUpdate_ScheduleRelationship>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TripUpdate_StopTimeUpdate_ScheduleRelationship_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor(), enum_t_value);
}
inline bool TripUpdate_StopTimeUpdate_ScheduleRelationship_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripUpdate_StopTimeUpdate_ScheduleRelationship* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TripUpdate_StopTimeUpdate_ScheduleRelationship>(
    TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor(), name, value);
}
enum VehiclePosition_VehicleStopStatus : int {
  VehiclePosition_VehicleStopStatus_INCOMING_AT = 0,
  VehiclePosition_VehicleStopStatus_STOPPED_AT = 1,
  VehiclePosition_VehicleStopStatus_IN_TRANSIT_TO = 2
};
bool VehiclePosition_VehicleStopStatus_IsValid(int value);
constexpr VehiclePosition_VehicleStopStatus VehiclePosition_VehicleStopStatus_VehicleStopStatus_MIN = VehiclePosition_VehicleStopStatus_INCOMING_AT;
constexpr VehiclePosition_VehicleStopStatus VehiclePosition_VehicleStopStatus_VehicleStopStatus_MAX = VehiclePosition_VehicleStopStatus_IN_TRANSIT_TO;
constexpr int VehiclePosition_VehicleStopStatus_VehicleStopStatus_ARRAYSIZE = VehiclePosition_VehicleStopStatus_VehicleStopStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VehiclePosition_VehicleStopStatus_descriptor();
template<typename T>
inline const std::string& VehiclePosition_VehicleStopStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VehiclePosition_VehicleStopStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VehiclePosition_VehicleStopStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VehiclePosition_VehicleStopStatus_descriptor(), enum_t_value);
}
inline bool VehiclePosition_VehicleStopStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VehiclePosition_VehicleStopStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VehiclePosition_VehicleStopStatus>(
    VehiclePosition_VehicleStopStatus_descriptor(), name, value);
}
enum VehiclePosition_CongestionLevel : int {
  VehiclePosition_CongestionLevel_UNKNOWN_CONGESTION_LEVEL = 0,
  VehiclePosition_CongestionLevel_RUNNING_SMOOTHLY = 1,
  VehiclePosition_CongestionLevel_STOP_AND_GO = 2,
  VehiclePosition_CongestionLevel_CONGESTION = 3,
  VehiclePosition_CongestionLevel_SEVERE_CONGESTION = 4
};
bool VehiclePosition_CongestionLevel_IsValid(int value);
constexpr VehiclePosition_CongestionLevel VehiclePosition_CongestionLevel_CongestionLevel_MIN = VehiclePosition_CongestionLevel_UNKNOWN_CONGESTION_LEVEL;
constexpr VehiclePosition_CongestionLevel VehiclePosition_CongestionLevel_CongestionLevel_MAX = VehiclePosition_CongestionLevel_SEVERE_CONGESTION;
constexpr int VehiclePosition_CongestionLevel_CongestionLevel_ARRAYSIZE = VehiclePosition_CongestionLevel_CongestionLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VehiclePosition_CongestionLevel_descriptor();
template<typename T>
inline const std::string& VehiclePosition_CongestionLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VehiclePosition_CongestionLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VehiclePosition_CongestionLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VehiclePosition_CongestionLevel_descriptor(), enum_t_value);
}
inline bool VehiclePosition_CongestionLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VehiclePosition_CongestionLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VehiclePosition_CongestionLevel>(
    VehiclePosition_CongestionLevel_descriptor(), name, value);
}
enum VehiclePosition_OccupancyStatus : int {
  VehiclePosition_OccupancyStatus_EMPTY = 0,
  VehiclePosition_OccupancyStatus_MANY_SEATS_AVAILABLE = 1,
  VehiclePosition_OccupancyStatus_FEW_SEATS_AVAILABLE = 2,
  VehiclePosition_OccupancyStatus_STANDING_ROOM_ONLY = 3,
  VehiclePosition_OccupancyStatus_CRUSHED_STANDING_ROOM_ONLY = 4,
  VehiclePosition_OccupancyStatus_FULL = 5,
  VehiclePosition_OccupancyStatus_NOT_ACCEPTING_PASSENGERS = 6,
  VehiclePosition_OccupancyStatus_NO_DATA_AVAILABLE = 7,
  VehiclePosition_OccupancyStatus_NOT_BOARDABLE = 8
};
bool VehiclePosition_OccupancyStatus_IsValid(int value);
constexpr VehiclePosition_OccupancyStatus VehiclePosition_OccupancyStatus_OccupancyStatus_MIN = VehiclePosition_OccupancyStatus_EMPTY;
constexpr VehiclePosition_OccupancyStatus VehiclePosition_OccupancyStatus_OccupancyStatus_MAX = VehiclePosition_OccupancyStatus_NOT_BOARDABLE;
constexpr int VehiclePosition_OccupancyStatus_OccupancyStatus_ARRAYSIZE = VehiclePosition_OccupancyStatus_OccupancyStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VehiclePosition_OccupancyStatus_descriptor();
template<typename T>
inline const std::string& VehiclePosition_OccupancyStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VehiclePosition_OccupancyStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VehiclePosition_OccupancyStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VehiclePosition_OccupancyStatus_descriptor(), enum_t_value);
}
inline bool VehiclePosition_OccupancyStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VehiclePosition_OccupancyStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VehiclePosition_OccupancyStatus>(
    VehiclePosition_OccupancyStatus_descriptor(), name, value);
}
enum Alert_Cause : int {
  Alert_Cause_UNKNOWN_CAUSE = 1,
  Alert_Cause_OTHER_CAUSE = 2,
  Alert_Cause_TECHNICAL_PROBLEM = 3,
  Alert_Cause_STRIKE = 4,
  Alert_Cause_DEMONSTRATION = 5,
  Alert_Cause_ACCIDENT = 6,
  Alert_Cause_HOLIDAY = 7,
  Alert_Cause_WEATHER = 8,
  Alert_Cause_MAINTENANCE = 9,
  Alert_Cause_CONSTRUCTION = 10,
  Alert_Cause_POLICE_ACTIVITY = 11,
  Alert_Cause_MEDICAL_EMERGENCY = 12
};
bool Alert_Cause_IsValid(int value);
constexpr Alert_Cause Alert_Cause_Cause_MIN = Alert_Cause_UNKNOWN_CAUSE;
constexpr Alert_Cause Alert_Cause_Cause_MAX = Alert_Cause_MEDICAL_EMERGENCY;
constexpr int Alert_Cause_Cause_ARRAYSIZE = Alert_Cause_Cause_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Alert_Cause_descriptor();
template<typename T>
inline const std::string& Alert_Cause_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Alert_Cause>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Alert_Cause_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Alert_Cause_descriptor(), enum_t_value);
}
inline bool Alert_Cause_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Alert_Cause* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Alert_Cause>(
    Alert_Cause_descriptor(), name, value);
}
enum Alert_Effect : int {
  Alert_Effect_NO_SERVICE = 1,
  Alert_Effect_REDUCED_SERVICE = 2,
  Alert_Effect_SIGNIFICANT_DELAYS = 3,
  Alert_Effect_DETOUR = 4,
  Alert_Effect_ADDITIONAL_SERVICE = 5,
  Alert_Effect_MODIFIED_SERVICE = 6,
  Alert_Effect_OTHER_EFFECT = 7,
  Alert_Effect_UNKNOWN_EFFECT = 8,
  Alert_Effect_STOP_MOVED = 9,
  Alert_Effect_NO_EFFECT = 10,
  Alert_Effect_ACCESSIBILITY_ISSUE = 11
};
bool Alert_Effect_IsValid(int value);
constexpr Alert_Effect Alert_Effect_Effect_MIN = Alert_Effect_NO_SERVICE;
constexpr Alert_Effect Alert_Effect_Effect_MAX = Alert_Effect_ACCESSIBILITY_ISSUE;
constexpr int Alert_Effect_Effect_ARRAYSIZE = Alert_Effect_Effect_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Alert_Effect_descriptor();
template<typename T>
inline const std::string& Alert_Effect_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Alert_Effect>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Alert_Effect_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Alert_Effect_descriptor(), enum_t_value);
}
inline bool Alert_Effect_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Alert_Effect* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Alert_Effect>(
    Alert_Effect_descriptor(), name, value);
}
enum Alert_SeverityLevel : int {
  Alert_SeverityLevel_UNKNOWN_SEVERITY = 1,
  Alert_SeverityLevel_INFO = 2,
  Alert_SeverityLevel_WARNING = 3,
  Alert_SeverityLevel_SEVERE = 4
};
bool Alert_SeverityLevel_IsValid(int value);
constexpr Alert_SeverityLevel Alert_SeverityLevel_SeverityLevel_MIN = Alert_SeverityLevel_UNKNOWN_SEVERITY;
constexpr Alert_SeverityLevel Alert_SeverityLevel_SeverityLevel_MAX = Alert_SeverityLevel_SEVERE;
constexpr int Alert_SeverityLevel_SeverityLevel_ARRAYSIZE = Alert_SeverityLevel_SeverityLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Alert_SeverityLevel_descriptor();
template<typename T>
inline const std::string& Alert_SeverityLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Alert_SeverityLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Alert_SeverityLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Alert_SeverityLevel_descriptor(), enum_t_value);
}
inline bool Alert_SeverityLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Alert_SeverityLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Alert_SeverityLevel>(
    Alert_SeverityLevel_descriptor(), name, value);
}
enum TripDescriptor_ScheduleRelationship : int {
  TripDescriptor_ScheduleRelationship_SCHEDULED = 0,
  TripDescriptor_ScheduleRelationship_ADDED = 1,
  TripDescriptor_ScheduleRelationship_UNSCHEDULED = 2,
  TripDescriptor_ScheduleRelationship_CANCELED = 3,
  TripDescriptor_ScheduleRelationship_REPLACEMENT PROTOBUF_DEPRECATED_ENUM = 5,
  TripDescriptor_ScheduleRelationship_DUPLICATED = 6
};
bool TripDescriptor_ScheduleRelationship_IsValid(int value);
constexpr TripDescriptor_ScheduleRelationship TripDescriptor_ScheduleRelationship_ScheduleRelationship_MIN = TripDescriptor_ScheduleRelationship_SCHEDULED;
constexpr TripDescriptor_ScheduleRelationship TripDescriptor_ScheduleRelationship_ScheduleRelationship_MAX = TripDescriptor_ScheduleRelationship_DUPLICATED;
constexpr int TripDescriptor_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE = TripDescriptor_ScheduleRelationship_ScheduleRelationship_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TripDescriptor_ScheduleRelationship_descriptor();
template<typename T>
inline const std::string& TripDescriptor_ScheduleRelationship_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TripDescriptor_ScheduleRelationship>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TripDescriptor_ScheduleRelationship_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TripDescriptor_ScheduleRelationship_descriptor(), enum_t_value);
}
inline bool TripDescriptor_ScheduleRelationship_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripDescriptor_ScheduleRelationship* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TripDescriptor_ScheduleRelationship>(
    TripDescriptor_ScheduleRelationship_descriptor(), name, value);
}
// ===================================================================

class FeedMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.FeedMessage) */ {
 public:
  inline FeedMessage() : FeedMessage(nullptr) {}
  ~FeedMessage() override;
  explicit PROTOBUF_CONSTEXPR FeedMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedMessage(const FeedMessage& from);
  FeedMessage(FeedMessage&& from) noexcept
    : FeedMessage() {
    *this = ::std::move(from);
  }

  inline FeedMessage& operator=(const FeedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedMessage& operator=(FeedMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedMessage* internal_default_instance() {
    return reinterpret_cast<const FeedMessage*>(
               &_FeedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FeedMessage& a, FeedMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedMessage& from) {
    FeedMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_realtime.FeedMessage";
  }
  protected:
  explicit FeedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .transit_realtime.FeedEntity entity = 2;
  int entity_size() const;
  private:
  int _internal_entity_size() const;
  public:
  void clear_entity();
  ::transit_realtime::FeedEntity* mutable_entity(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::FeedEntity >*
      mutable_entity();
  private:
  const ::transit_realtime::FeedEntity& _internal_entity(int index) const;
  ::transit_realtime::FeedEntity* _internal_add_entity();
  public:
  const ::transit_realtime::FeedEntity& entity(int index) const;
  ::transit_realtime::FeedEntity* add_entity();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::FeedEntity >&
      entity() const;

  // required .transit_realtime.FeedHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::transit_realtime::FeedHeader& header() const;
  PROTOBUF_NODISCARD ::transit_realtime::FeedHeader* release_header();
  ::transit_realtime::FeedHeader* mutable_header();
  void set_allocated_header(::transit_realtime::FeedHeader* header);
  private:
  const ::transit_realtime::FeedHeader& _internal_header() const;
  ::transit_realtime::FeedHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::transit_realtime::FeedHeader* header);
  ::transit_realtime::FeedHeader* unsafe_arena_release_header();


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedMessage, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedMessage, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedMessage, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedMessage, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedMessage, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedMessage, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedMessage, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedMessage, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              FeedMessage, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedMessage, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedMessage, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedMessage, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedMessage, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedMessage, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedMessage, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedMessage, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedMessage, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:transit_realtime.FeedMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::FeedEntity > entity_;
    ::transit_realtime::FeedHeader* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class FeedHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.FeedHeader) */ {
 public:
  inline FeedHeader() : FeedHeader(nullptr) {}
  ~FeedHeader() override;
  explicit PROTOBUF_CONSTEXPR FeedHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedHeader(const FeedHeader& from);
  FeedHeader(FeedHeader&& from) noexcept
    : FeedHeader() {
    *this = ::std::move(from);
  }

  inline FeedHeader& operator=(const FeedHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedHeader& operator=(FeedHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedHeader* internal_default_instance() {
    return reinterpret_cast<const FeedHeader*>(
               &_FeedHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FeedHeader& a, FeedHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedHeader& from) {
    FeedHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_realtime.FeedHeader";
  }
  protected:
  explicit FeedHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FeedHeader_Incrementality Incrementality;
  static constexpr Incrementality FULL_DATASET =
    FeedHeader_Incrementality_FULL_DATASET;
  static constexpr Incrementality DIFFERENTIAL =
    FeedHeader_Incrementality_DIFFERENTIAL;
  static inline bool Incrementality_IsValid(int value) {
    return FeedHeader_Incrementality_IsValid(value);
  }
  static constexpr Incrementality Incrementality_MIN =
    FeedHeader_Incrementality_Incrementality_MIN;
  static constexpr Incrementality Incrementality_MAX =
    FeedHeader_Incrementality_Incrementality_MAX;
  static constexpr int Incrementality_ARRAYSIZE =
    FeedHeader_Incrementality_Incrementality_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Incrementality_descriptor() {
    return FeedHeader_Incrementality_descriptor();
  }
  template<typename T>
  static inline const std::string& Incrementality_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Incrementality>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Incrementality_Name.");
    return FeedHeader_Incrementality_Name(enum_t_value);
  }
  static inline bool Incrementality_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Incrementality* value) {
    return FeedHeader_Incrementality_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGtfsRealtimeVersionFieldNumber = 1,
    kTimestampFieldNumber = 3,
    kIncrementalityFieldNumber = 2,
  };
  // required string gtfs_realtime_version = 1;
  bool has_gtfs_realtime_version() const;
  private:
  bool _internal_has_gtfs_realtime_version() const;
  public:
  void clear_gtfs_realtime_version();
  const std::string& gtfs_realtime_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gtfs_realtime_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gtfs_realtime_version();
  PROTOBUF_NODISCARD std::string* release_gtfs_realtime_version();
  void set_allocated_gtfs_realtime_version(std::string* gtfs_realtime_version);
  private:
  const std::string& _internal_gtfs_realtime_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gtfs_realtime_version(const std::string& value);
  std::string* _internal_mutable_gtfs_realtime_version();
  public:

  // optional uint64 timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];
  bool has_incrementality() const;
  private:
  bool _internal_has_incrementality() const;
  public:
  void clear_incrementality();
  ::transit_realtime::FeedHeader_Incrementality incrementality() const;
  void set_incrementality(::transit_realtime::FeedHeader_Incrementality value);
  private:
  ::transit_realtime::FeedHeader_Incrementality _internal_incrementality() const;
  void _internal_set_incrementality(::transit_realtime::FeedHeader_Incrementality value);
  public:


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedHeader, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedHeader, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedHeader, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedHeader, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedHeader, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedHeader, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedHeader, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedHeader, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              FeedHeader, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedHeader, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedHeader, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedHeader, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedHeader, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedHeader, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedHeader, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedHeader, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedHeader, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:transit_realtime.FeedHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gtfs_realtime_version_;
    uint64_t timestamp_;
    int incrementality_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class FeedEntity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.FeedEntity) */ {
 public:
  inline FeedEntity() : FeedEntity(nullptr) {}
  ~FeedEntity() override;
  explicit PROTOBUF_CONSTEXPR FeedEntity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedEntity(const FeedEntity& from);
  FeedEntity(FeedEntity&& from) noexcept
    : FeedEntity() {
    *this = ::std::move(from);
  }

  inline FeedEntity& operator=(const FeedEntity& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedEntity& operator=(FeedEntity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedEntity& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedEntity* internal_default_instance() {
    return reinterpret_cast<const FeedEntity*>(
               &_FeedEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FeedEntity& a, FeedEntity& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedEntity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedEntity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedEntity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedEntity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedEntity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeedEntity& from) {
    FeedEntity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedEntity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_realtime.FeedEntity";
  }
  protected:
  explicit FeedEntity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTripUpdateFieldNumber = 3,
    kVehicleFieldNumber = 4,
    kAlertFieldNumber = 5,
    kShapeFieldNumber = 6,
    kIsDeletedFieldNumber = 2,
  };
  // required string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional .transit_realtime.TripUpdate trip_update = 3;
  bool has_trip_update() const;
  private:
  bool _internal_has_trip_update() const;
  public:
  void clear_trip_update();
  const ::transit_realtime::TripUpdate& trip_update() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripUpdate* release_trip_update();
  ::transit_realtime::TripUpdate* mutable_trip_update();
  void set_allocated_trip_update(::transit_realtime::TripUpdate* trip_update);
  private:
  const ::transit_realtime::TripUpdate& _internal_trip_update() const;
  ::transit_realtime::TripUpdate* _internal_mutable_trip_update();
  public:
  void unsafe_arena_set_allocated_trip_update(
      ::transit_realtime::TripUpdate* trip_update);
  ::transit_realtime::TripUpdate* unsafe_arena_release_trip_update();

  // optional .transit_realtime.VehiclePosition vehicle = 4;
  bool has_vehicle() const;
  private:
  bool _internal_has_vehicle() const;
  public:
  void clear_vehicle();
  const ::transit_realtime::VehiclePosition& vehicle() const;
  PROTOBUF_NODISCARD ::transit_realtime::VehiclePosition* release_vehicle();
  ::transit_realtime::VehiclePosition* mutable_vehicle();
  void set_allocated_vehicle(::transit_realtime::VehiclePosition* vehicle);
  private:
  const ::transit_realtime::VehiclePosition& _internal_vehicle() const;
  ::transit_realtime::VehiclePosition* _internal_mutable_vehicle();
  public:
  void unsafe_arena_set_allocated_vehicle(
      ::transit_realtime::VehiclePosition* vehicle);
  ::transit_realtime::VehiclePosition* unsafe_arena_release_vehicle();

  // optional .transit_realtime.Alert alert = 5;
  bool has_alert() const;
  private:
  bool _internal_has_alert() const;
  public:
  void clear_alert();
  const ::transit_realtime::Alert& alert() const;
  PROTOBUF_NODISCARD ::transit_realtime::Alert* release_alert();
  ::transit_realtime::Alert* mutable_alert();
  void set_allocated_alert(::transit_realtime::Alert* alert);
  private:
  const ::transit_realtime::Alert& _internal_alert() const;
  ::transit_realtime::Alert* _internal_mutable_alert();
  public:
  void unsafe_arena_set_allocated_alert(
      ::transit_realtime::Alert* alert);
  ::transit_realtime::Alert* unsafe_arena_release_alert();

  // optional .transit_realtime.Shape shape = 6;
  bool has_shape() const;
  private:
  bool _internal_has_shape() const;
  public:
  void clear_shape();
  const ::transit_realtime::Shape& shape() const;
  PROTOBUF_NODISCARD ::transit_realtime::Shape* release_shape();
  ::transit_realtime::Shape* mutable_shape();
  void set_allocated_shape(::transit_realtime::Shape* shape);
  private:
  const ::transit_realtime::Shape& _internal_shape() const;
  ::transit_realtime::Shape* _internal_mutable_shape();
  public:
  void unsafe_arena_set_allocated_shape(
      ::transit_realtime::Shape* shape);
  ::transit_realtime::Shape* unsafe_arena_release_shape();

  // optional bool is_deleted = 2 [default = false];
  bool has_is_deleted() const;
  private:
  bool _internal_has_is_deleted() const;
  public:
  void clear_is_deleted();
  bool is_deleted() const;
  void set_is_deleted(bool value);
  private:
  bool _internal_is_deleted() const;
  void _internal_set_is_deleted(bool value);
  public:


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedEntity, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedEntity, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedEntity, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedEntity, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedEntity, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedEntity, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedEntity, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedEntity, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              FeedEntity, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedEntity, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedEntity, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedEntity, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedEntity, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedEntity, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedEntity, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedEntity, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FeedEntity, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:transit_realtime.FeedEntity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::transit_realtime::TripUpdate* trip_update_;
    ::transit_realtime::VehiclePosition* vehicle_;
    ::transit_realtime::Alert* alert_;
    ::transit_realtime::Shape* shape_;
    bool is_deleted_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TripUpdate_StopTimeEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TripUpdate.StopTimeEvent) */ {
 public:
  inline TripUpdate_StopTimeEvent() : TripUpdate_StopTimeEvent(nullptr) {}
  ~TripUpdate_StopTimeEvent() override;
  explicit PROTOBUF_CONSTEXPR TripUpdate_StopTimeEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripUpdate_StopTimeEvent(const TripUpdate_StopTimeEvent& from);
  TripUpdate_StopTimeEvent(TripUpdate_StopTimeEvent&& from) noexcept
    : TripUpdate_StopTimeEvent() {
    *this = ::std::move(from);
  }

  inline TripUpdate_StopTimeEvent& operator=(const TripUpdate_StopTimeEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripUpdate_StopTimeEvent& operator=(TripUpdate_StopTimeEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripUpdate_StopTimeEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripUpdate_StopTimeEvent* internal_default_instance() {
    return reinterpret_cast<const TripUpdate_StopTimeEvent*>(
               &_TripUpdate_StopTimeEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TripUpdate_StopTimeEvent& a, TripUpdate_StopTimeEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(TripUpdate_StopTimeEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripUpdate_StopTimeEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripUpdate_StopTimeEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripUpdate_StopTimeEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TripUpdate_StopTimeEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TripUpdate_StopTimeEvent& from) {
    TripUpdate_StopTimeEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TripUpdate_StopTimeEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_realtime.TripUpdate.StopTimeEvent";
  }
  protected:
  explicit TripUpdate_StopTimeEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 2,
    kDelayFieldNumber = 1,
    kUncertaintyFieldNumber = 3,
  };
  // optional int64 time = 2;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  int64_t time() const;
  void set_time(int64_t value);
  private:
  int64_t _internal_time() const;
  void _internal_set_time(int64_t value);
  public:

  // optional int32 delay = 1;
  bool has_delay() const;
  private:
  bool _internal_has_delay() const;
  public:
  void clear_delay();
  int32_t delay() const;
  void set_delay(int32_t value);
  private:
  int32_t _internal_delay() const;
  void _internal_set_delay(int32_t value);
  public:

  // optional int32 uncertainty = 3;
  bool has_uncertainty() const;
  private:
  bool _internal_has_uncertainty() const;
  public:
  void clear_uncertainty();
  int32_t uncertainty() const;
  void set_uncertainty(int32_t value);
  private:
  int32_t _internal_uncertainty() const;
  void _internal_set_uncertainty(int32_t value);
  public:


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeEvent, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeEvent, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeEvent, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeEvent, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeEvent, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeEvent, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeEvent, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeEvent, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              TripUpdate_StopTimeEvent, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeEvent, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeEvent, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeEvent, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeEvent, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeEvent, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeEvent, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeEvent, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeEvent, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate.StopTimeEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t time_;
    int32_t delay_;
    int32_t uncertainty_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TripUpdate_StopTimeUpdate_StopTimeProperties final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties) */ {
 public:
  inline TripUpdate_StopTimeUpdate_StopTimeProperties() : TripUpdate_StopTimeUpdate_StopTimeProperties(nullptr) {}
  ~TripUpdate_StopTimeUpdate_StopTimeProperties() override;
  explicit PROTOBUF_CONSTEXPR TripUpdate_StopTimeUpdate_StopTimeProperties(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripUpdate_StopTimeUpdate_StopTimeProperties(const TripUpdate_StopTimeUpdate_StopTimeProperties& from);
  TripUpdate_StopTimeUpdate_StopTimeProperties(TripUpdate_StopTimeUpdate_StopTimeProperties&& from) noexcept
    : TripUpdate_StopTimeUpdate_StopTimeProperties() {
    *this = ::std::move(from);
  }

  inline TripUpdate_StopTimeUpdate_StopTimeProperties& operator=(const TripUpdate_StopTimeUpdate_StopTimeProperties& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripUpdate_StopTimeUpdate_StopTimeProperties& operator=(TripUpdate_StopTimeUpdate_StopTimeProperties&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripUpdate_StopTimeUpdate_StopTimeProperties& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripUpdate_StopTimeUpdate_StopTimeProperties* internal_default_instance() {
    return reinterpret_cast<const TripUpdate_StopTimeUpdate_StopTimeProperties*>(
               &_TripUpdate_StopTimeUpdate_StopTimeProperties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TripUpdate_StopTimeUpdate_StopTimeProperties& a, TripUpdate_StopTimeUpdate_StopTimeProperties& b) {
    a.Swap(&b);
  }
  inline void Swap(TripUpdate_StopTimeUpdate_StopTimeProperties* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripUpdate_StopTimeUpdate_StopTimeProperties* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripUpdate_StopTimeUpdate_StopTimeProperties* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripUpdate_StopTimeUpdate_StopTimeProperties>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TripUpdate_StopTimeUpdate_StopTimeProperties& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TripUpdate_StopTimeUpdate_StopTimeProperties& from) {
    TripUpdate_StopTimeUpdate_StopTimeProperties::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TripUpdate_StopTimeUpdate_StopTimeProperties* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties";
  }
  protected:
  explicit TripUpdate_StopTimeUpdate_StopTimeProperties(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssignedStopIdFieldNumber = 1,
  };
  // optional string assigned_stop_id = 1;
  bool has_assigned_stop_id() const;
  private:
  bool _internal_has_assigned_stop_id() const;
  public:
  void clear_assigned_stop_id();
  const std::string& assigned_stop_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_assigned_stop_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_assigned_stop_id();
  PROTOBUF_NODISCARD std::string* release_assigned_stop_id();
  void set_allocated_assigned_stop_id(std::string* assigned_stop_id);
  private:
  const std::string& _internal_assigned_stop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assigned_stop_id(const std::string& value);
  std::string* _internal_mutable_assigned_stop_id();
  public:


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr assigned_stop_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TripUpdate_StopTimeUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TripUpdate.StopTimeUpdate) */ {
 public:
  inline TripUpdate_StopTimeUpdate() : TripUpdate_StopTimeUpdate(nullptr) {}
  ~TripUpdate_StopTimeUpdate() override;
  explicit PROTOBUF_CONSTEXPR TripUpdate_StopTimeUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripUpdate_StopTimeUpdate(const TripUpdate_StopTimeUpdate& from);
  TripUpdate_StopTimeUpdate(TripUpdate_StopTimeUpdate&& from) noexcept
    : TripUpdate_StopTimeUpdate() {
    *this = ::std::move(from);
  }

  inline TripUpdate_StopTimeUpdate& operator=(const TripUpdate_StopTimeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripUpdate_StopTimeUpdate& operator=(TripUpdate_StopTimeUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripUpdate_StopTimeUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripUpdate_StopTimeUpdate* internal_default_instance() {
    return reinterpret_cast<const TripUpdate_StopTimeUpdate*>(
               &_TripUpdate_StopTimeUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TripUpdate_StopTimeUpdate& a, TripUpdate_StopTimeUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(TripUpdate_StopTimeUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripUpdate_StopTimeUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripUpdate_StopTimeUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripUpdate_StopTimeUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TripUpdate_StopTimeUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TripUpdate_StopTimeUpdate& from) {
    TripUpdate_StopTimeUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TripUpdate_StopTimeUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_realtime.TripUpdate.StopTimeUpdate";
  }
  protected:
  explicit TripUpdate_StopTimeUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TripUpdate_StopTimeUpdate_StopTimeProperties StopTimeProperties;

  typedef TripUpdate_StopTimeUpdate_ScheduleRelationship ScheduleRelationship;
  static constexpr ScheduleRelationship SCHEDULED =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_SCHEDULED;
  static constexpr ScheduleRelationship SKIPPED =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_SKIPPED;
  static constexpr ScheduleRelationship NO_DATA =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_NO_DATA;
  static constexpr ScheduleRelationship UNSCHEDULED =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_UNSCHEDULED;
  static inline bool ScheduleRelationship_IsValid(int value) {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValid(value);
  }
  static constexpr ScheduleRelationship ScheduleRelationship_MIN =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MIN;
  static constexpr ScheduleRelationship ScheduleRelationship_MAX =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MAX;
  static constexpr int ScheduleRelationship_ARRAYSIZE =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ScheduleRelationship_descriptor() {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor();
  }
  template<typename T>
  static inline const std::string& ScheduleRelationship_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScheduleRelationship>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScheduleRelationship_Name.");
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_Name(enum_t_value);
  }
  static inline bool ScheduleRelationship_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ScheduleRelationship* value) {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStopIdFieldNumber = 4,
    kArrivalFieldNumber = 2,
    kDepartureFieldNumber = 3,
    kStopTimePropertiesFieldNumber = 6,
    kStopSequenceFieldNumber = 1,
    kScheduleRelationshipFieldNumber = 5,
    kDepartureOccupancyStatusFieldNumber = 7,
  };
  // optional string stop_id = 4;
  bool has_stop_id() const;
  private:
  bool _internal_has_stop_id() const;
  public:
  void clear_stop_id();
  const std::string& stop_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stop_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stop_id();
  PROTOBUF_NODISCARD std::string* release_stop_id();
  void set_allocated_stop_id(std::string* stop_id);
  private:
  const std::string& _internal_stop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_id(const std::string& value);
  std::string* _internal_mutable_stop_id();
  public:

  // optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;
  bool has_arrival() const;
  private:
  bool _internal_has_arrival() const;
  public:
  void clear_arrival();
  const ::transit_realtime::TripUpdate_StopTimeEvent& arrival() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripUpdate_StopTimeEvent* release_arrival();
  ::transit_realtime::TripUpdate_StopTimeEvent* mutable_arrival();
  void set_allocated_arrival(::transit_realtime::TripUpdate_StopTimeEvent* arrival);
  private:
  const ::transit_realtime::TripUpdate_StopTimeEvent& _internal_arrival() const;
  ::transit_realtime::TripUpdate_StopTimeEvent* _internal_mutable_arrival();
  public:
  void unsafe_arena_set_allocated_arrival(
      ::transit_realtime::TripUpdate_StopTimeEvent* arrival);
  ::transit_realtime::TripUpdate_StopTimeEvent* unsafe_arena_release_arrival();

  // optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;
  bool has_departure() const;
  private:
  bool _internal_has_departure() const;
  public:
  void clear_departure();
  const ::transit_realtime::TripUpdate_StopTimeEvent& departure() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripUpdate_StopTimeEvent* release_departure();
  ::transit_realtime::TripUpdate_StopTimeEvent* mutable_departure();
  void set_allocated_departure(::transit_realtime::TripUpdate_StopTimeEvent* departure);
  private:
  const ::transit_realtime::TripUpdate_StopTimeEvent& _internal_departure() const;
  ::transit_realtime::TripUpdate_StopTimeEvent* _internal_mutable_departure();
  public:
  void unsafe_arena_set_allocated_departure(
      ::transit_realtime::TripUpdate_StopTimeEvent* departure);
  ::transit_realtime::TripUpdate_StopTimeEvent* unsafe_arena_release_departure();

  // optional .transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;
  bool has_stop_time_properties() const;
  private:
  bool _internal_has_stop_time_properties() const;
  public:
  void clear_stop_time_properties();
  const ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties& stop_time_properties() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* release_stop_time_properties();
  ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* mutable_stop_time_properties();
  void set_allocated_stop_time_properties(::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* stop_time_properties);
  private:
  const ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties& _internal_stop_time_properties() const;
  ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* _internal_mutable_stop_time_properties();
  public:
  void unsafe_arena_set_allocated_stop_time_properties(
      ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* stop_time_properties);
  ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* unsafe_arena_release_stop_time_properties();

  // optional uint32 stop_sequence = 1;
  bool has_stop_sequence() const;
  private:
  bool _internal_has_stop_sequence() const;
  public:
  void clear_stop_sequence();
  uint32_t stop_sequence() const;
  void set_stop_sequence(uint32_t value);
  private:
  uint32_t _internal_stop_sequence() const;
  void _internal_set_stop_sequence(uint32_t value);
  public:

  // optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];
  bool has_schedule_relationship() const;
  private:
  bool _internal_has_schedule_relationship() const;
  public:
  void clear_schedule_relationship();
  ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship schedule_relationship() const;
  void set_schedule_relationship(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship value);
  private:
  ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship _internal_schedule_relationship() const;
  void _internal_set_schedule_relationship(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship value);
  public:

  // optional .transit_realtime.VehiclePosition.OccupancyStatus departure_occupancy_status = 7;
  bool has_departure_occupancy_status() const;
  private:
  bool _internal_has_departure_occupancy_status() const;
  public:
  void clear_departure_occupancy_status();
  ::transit_realtime::VehiclePosition_OccupancyStatus departure_occupancy_status() const;
  void set_departure_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value);
  private:
  ::transit_realtime::VehiclePosition_OccupancyStatus _internal_departure_occupancy_status() const;
  void _internal_set_departure_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value);
  public:


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              TripUpdate_StopTimeUpdate, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_StopTimeUpdate, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate.StopTimeUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_id_;
    ::transit_realtime::TripUpdate_StopTimeEvent* arrival_;
    ::transit_realtime::TripUpdate_StopTimeEvent* departure_;
    ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* stop_time_properties_;
    uint32_t stop_sequence_;
    int schedule_relationship_;
    int departure_occupancy_status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TripUpdate_TripProperties final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TripUpdate.TripProperties) */ {
 public:
  inline TripUpdate_TripProperties() : TripUpdate_TripProperties(nullptr) {}
  ~TripUpdate_TripProperties() override;
  explicit PROTOBUF_CONSTEXPR TripUpdate_TripProperties(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripUpdate_TripProperties(const TripUpdate_TripProperties& from);
  TripUpdate_TripProperties(TripUpdate_TripProperties&& from) noexcept
    : TripUpdate_TripProperties() {
    *this = ::std::move(from);
  }

  inline TripUpdate_TripProperties& operator=(const TripUpdate_TripProperties& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripUpdate_TripProperties& operator=(TripUpdate_TripProperties&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripUpdate_TripProperties& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripUpdate_TripProperties* internal_default_instance() {
    return reinterpret_cast<const TripUpdate_TripProperties*>(
               &_TripUpdate_TripProperties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TripUpdate_TripProperties& a, TripUpdate_TripProperties& b) {
    a.Swap(&b);
  }
  inline void Swap(TripUpdate_TripProperties* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripUpdate_TripProperties* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripUpdate_TripProperties* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripUpdate_TripProperties>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TripUpdate_TripProperties& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TripUpdate_TripProperties& from) {
    TripUpdate_TripProperties::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TripUpdate_TripProperties* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_realtime.TripUpdate.TripProperties";
  }
  protected:
  explicit TripUpdate_TripProperties(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTripIdFieldNumber = 1,
    kStartDateFieldNumber = 2,
    kStartTimeFieldNumber = 3,
    kShapeIdFieldNumber = 4,
  };
  // optional string trip_id = 1;
  bool has_trip_id() const;
  private:
  bool _internal_has_trip_id() const;
  public:
  void clear_trip_id();
  const std::string& trip_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trip_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trip_id();
  PROTOBUF_NODISCARD std::string* release_trip_id();
  void set_allocated_trip_id(std::string* trip_id);
  private:
  const std::string& _internal_trip_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trip_id(const std::string& value);
  std::string* _internal_mutable_trip_id();
  public:

  // optional string start_date = 2;
  bool has_start_date() const;
  private:
  bool _internal_has_start_date() const;
  public:
  void clear_start_date();
  const std::string& start_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_date();
  PROTOBUF_NODISCARD std::string* release_start_date();
  void set_allocated_start_date(std::string* start_date);
  private:
  const std::string& _internal_start_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_date(const std::string& value);
  std::string* _internal_mutable_start_date();
  public:

  // optional string start_time = 3;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const std::string& start_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_time();
  PROTOBUF_NODISCARD std::string* release_start_time();
  void set_allocated_start_time(std::string* start_time);
  private:
  const std::string& _internal_start_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_time(const std::string& value);
  std::string* _internal_mutable_start_time();
  public:

  // optional string shape_id = 4;
  bool has_shape_id() const;
  private:
  bool _internal_has_shape_id() const;
  public:
  void clear_shape_id();
  const std::string& shape_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shape_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shape_id();
  PROTOBUF_NODISCARD std::string* release_shape_id();
  void set_allocated_shape_id(std::string* shape_id);
  private:
  const std::string& _internal_shape_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shape_id(const std::string& value);
  std::string* _internal_mutable_shape_id();
  public:


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_TripProperties, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_TripProperties, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_TripProperties, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_TripProperties, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_TripProperties, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_TripProperties, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_TripProperties, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_TripProperties, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              TripUpdate_TripProperties, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_TripProperties, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_TripProperties, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_TripProperties, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_TripProperties, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_TripProperties, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_TripProperties, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_TripProperties, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate_TripProperties, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate.TripProperties)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trip_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_date_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shape_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TripUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TripUpdate) */ {
 public:
  inline TripUpdate() : TripUpdate(nullptr) {}
  ~TripUpdate() override;
  explicit PROTOBUF_CONSTEXPR TripUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripUpdate(const TripUpdate& from);
  TripUpdate(TripUpdate&& from) noexcept
    : TripUpdate() {
    *this = ::std::move(from);
  }

  inline TripUpdate& operator=(const TripUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripUpdate& operator=(TripUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripUpdate* internal_default_instance() {
    return reinterpret_cast<const TripUpdate*>(
               &_TripUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TripUpdate& a, TripUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(TripUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TripUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TripUpdate& from) {
    TripUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TripUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_realtime.TripUpdate";
  }
  protected:
  explicit TripUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TripUpdate_StopTimeEvent StopTimeEvent;
  typedef TripUpdate_StopTimeUpdate StopTimeUpdate;
  typedef TripUpdate_TripProperties TripProperties;

  // accessors -------------------------------------------------------

  enum : int {
    kStopTimeUpdateFieldNumber = 2,
    kTripFieldNumber = 1,
    kVehicleFieldNumber = 3,
    kTripPropertiesFieldNumber = 6,
    kTimestampFieldNumber = 4,
    kDelayFieldNumber = 5,
  };
  // repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;
  int stop_time_update_size() const;
  private:
  int _internal_stop_time_update_size() const;
  public:
  void clear_stop_time_update();
  ::transit_realtime::TripUpdate_StopTimeUpdate* mutable_stop_time_update(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate >*
      mutable_stop_time_update();
  private:
  const ::transit_realtime::TripUpdate_StopTimeUpdate& _internal_stop_time_update(int index) const;
  ::transit_realtime::TripUpdate_StopTimeUpdate* _internal_add_stop_time_update();
  public:
  const ::transit_realtime::TripUpdate_StopTimeUpdate& stop_time_update(int index) const;
  ::transit_realtime::TripUpdate_StopTimeUpdate* add_stop_time_update();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate >&
      stop_time_update() const;

  // required .transit_realtime.TripDescriptor trip = 1;
  bool has_trip() const;
  private:
  bool _internal_has_trip() const;
  public:
  void clear_trip();
  const ::transit_realtime::TripDescriptor& trip() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripDescriptor* release_trip();
  ::transit_realtime::TripDescriptor* mutable_trip();
  void set_allocated_trip(::transit_realtime::TripDescriptor* trip);
  private:
  const ::transit_realtime::TripDescriptor& _internal_trip() const;
  ::transit_realtime::TripDescriptor* _internal_mutable_trip();
  public:
  void unsafe_arena_set_allocated_trip(
      ::transit_realtime::TripDescriptor* trip);
  ::transit_realtime::TripDescriptor* unsafe_arena_release_trip();

  // optional .transit_realtime.VehicleDescriptor vehicle = 3;
  bool has_vehicle() const;
  private:
  bool _internal_has_vehicle() const;
  public:
  void clear_vehicle();
  const ::transit_realtime::VehicleDescriptor& vehicle() const;
  PROTOBUF_NODISCARD ::transit_realtime::VehicleDescriptor* release_vehicle();
  ::transit_realtime::VehicleDescriptor* mutable_vehicle();
  void set_allocated_vehicle(::transit_realtime::VehicleDescriptor* vehicle);
  private:
  const ::transit_realtime::VehicleDescriptor& _internal_vehicle() const;
  ::transit_realtime::VehicleDescriptor* _internal_mutable_vehicle();
  public:
  void unsafe_arena_set_allocated_vehicle(
      ::transit_realtime::VehicleDescriptor* vehicle);
  ::transit_realtime::VehicleDescriptor* unsafe_arena_release_vehicle();

  // optional .transit_realtime.TripUpdate.TripProperties trip_properties = 6;
  bool has_trip_properties() const;
  private:
  bool _internal_has_trip_properties() const;
  public:
  void clear_trip_properties();
  const ::transit_realtime::TripUpdate_TripProperties& trip_properties() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripUpdate_TripProperties* release_trip_properties();
  ::transit_realtime::TripUpdate_TripProperties* mutable_trip_properties();
  void set_allocated_trip_properties(::transit_realtime::TripUpdate_TripProperties* trip_properties);
  private:
  const ::transit_realtime::TripUpdate_TripProperties& _internal_trip_properties() const;
  ::transit_realtime::TripUpdate_TripProperties* _internal_mutable_trip_properties();
  public:
  void unsafe_arena_set_allocated_trip_properties(
      ::transit_realtime::TripUpdate_TripProperties* trip_properties);
  ::transit_realtime::TripUpdate_TripProperties* unsafe_arena_release_trip_properties();

  // optional uint64 timestamp = 4;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // optional int32 delay = 5;
  bool has_delay() const;
  private:
  bool _internal_has_delay() const;
  public:
  void clear_delay();
  int32_t delay() const;
  void set_delay(int32_t value);
  private:
  int32_t _internal_delay() const;
  void _internal_set_delay(int32_t value);
  public:


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              TripUpdate, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripUpdate, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate > stop_time_update_;
    ::transit_realtime::TripDescriptor* trip_;
    ::transit_realtime::VehicleDescriptor* vehicle_;
    ::transit_realtime::TripUpdate_TripProperties* trip_properties_;
    uint64_t timestamp_;
    int32_t delay_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class VehiclePosition_CarriageDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.VehiclePosition.CarriageDetails) */ {
 public:
  inline VehiclePosition_CarriageDetails() : VehiclePosition_CarriageDetails(nullptr) {}
  ~VehiclePosition_CarriageDetails() override;
  explicit PROTOBUF_CONSTEXPR VehiclePosition_CarriageDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VehiclePosition_CarriageDetails(const VehiclePosition_CarriageDetails& from);
  VehiclePosition_CarriageDetails(VehiclePosition_CarriageDetails&& from) noexcept
    : VehiclePosition_CarriageDetails() {
    *this = ::std::move(from);
  }

  inline VehiclePosition_CarriageDetails& operator=(const VehiclePosition_CarriageDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehiclePosition_CarriageDetails& operator=(VehiclePosition_CarriageDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehiclePosition_CarriageDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehiclePosition_CarriageDetails* internal_default_instance() {
    return reinterpret_cast<const VehiclePosition_CarriageDetails*>(
               &_VehiclePosition_CarriageDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(VehiclePosition_CarriageDetails& a, VehiclePosition_CarriageDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(VehiclePosition_CarriageDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehiclePosition_CarriageDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehiclePosition_CarriageDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VehiclePosition_CarriageDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VehiclePosition_CarriageDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VehiclePosition_CarriageDetails& from) {
    VehiclePosition_CarriageDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehiclePosition_CarriageDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_realtime.VehiclePosition.CarriageDetails";
  }
  protected:
  explicit VehiclePosition_CarriageDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kLabelFieldNumber = 2,
    kCarriageSequenceFieldNumber = 5,
    kOccupancyStatusFieldNumber = 3,
    kOccupancyPercentageFieldNumber = 4,
  };
  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string label = 2;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // optional uint32 carriage_sequence = 5;
  bool has_carriage_sequence() const;
  private:
  bool _internal_has_carriage_sequence() const;
  public:
  void clear_carriage_sequence();
  uint32_t carriage_sequence() const;
  void set_carriage_sequence(uint32_t value);
  private:
  uint32_t _internal_carriage_sequence() const;
  void _internal_set_carriage_sequence(uint32_t value);
  public:

  // optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 3 [default = NO_DATA_AVAILABLE];
  bool has_occupancy_status() const;
  private:
  bool _internal_has_occupancy_status() const;
  public:
  void clear_occupancy_status();
  ::transit_realtime::VehiclePosition_OccupancyStatus occupancy_status() const;
  void set_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value);
  private:
  ::transit_realtime::VehiclePosition_OccupancyStatus _internal_occupancy_status() const;
  void _internal_set_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value);
  public:

  // optional int32 occupancy_percentage = 4 [default = -1];
  bool has_occupancy_percentage() const;
  private:
  bool _internal_has_occupancy_percentage() const;
  public:
  void clear_occupancy_percentage();
  int32_t occupancy_percentage() const;
  void set_occupancy_percentage(int32_t value);
  private:
  int32_t _internal_occupancy_percentage() const;
  void _internal_set_occupancy_percentage(int32_t value);
  public:


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition_CarriageDetails, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition_CarriageDetails, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition_CarriageDetails, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition_CarriageDetails, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition_CarriageDetails, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition_CarriageDetails, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition_CarriageDetails, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition_CarriageDetails, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              VehiclePosition_CarriageDetails, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition_CarriageDetails, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition_CarriageDetails, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition_CarriageDetails, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition_CarriageDetails, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition_CarriageDetails, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition_CarriageDetails, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition_CarriageDetails, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition_CarriageDetails, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:transit_realtime.VehiclePosition.CarriageDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    uint32_t carriage_sequence_;
    int occupancy_status_;
    int32_t occupancy_percentage_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class VehiclePosition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.VehiclePosition) */ {
 public:
  inline VehiclePosition() : VehiclePosition(nullptr) {}
  ~VehiclePosition() override;
  explicit PROTOBUF_CONSTEXPR VehiclePosition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VehiclePosition(const VehiclePosition& from);
  VehiclePosition(VehiclePosition&& from) noexcept
    : VehiclePosition() {
    *this = ::std::move(from);
  }

  inline VehiclePosition& operator=(const VehiclePosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehiclePosition& operator=(VehiclePosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehiclePosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehiclePosition* internal_default_instance() {
    return reinterpret_cast<const VehiclePosition*>(
               &_VehiclePosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(VehiclePosition& a, VehiclePosition& b) {
    a.Swap(&b);
  }
  inline void Swap(VehiclePosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehiclePosition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehiclePosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VehiclePosition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VehiclePosition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VehiclePosition& from) {
    VehiclePosition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehiclePosition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_realtime.VehiclePosition";
  }
  protected:
  explicit VehiclePosition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VehiclePosition_CarriageDetails CarriageDetails;

  typedef VehiclePosition_VehicleStopStatus VehicleStopStatus;
  static constexpr VehicleStopStatus INCOMING_AT =
    VehiclePosition_VehicleStopStatus_INCOMING_AT;
  static constexpr VehicleStopStatus STOPPED_AT =
    VehiclePosition_VehicleStopStatus_STOPPED_AT;
  static constexpr VehicleStopStatus IN_TRANSIT_TO =
    VehiclePosition_VehicleStopStatus_IN_TRANSIT_TO;
  static inline bool VehicleStopStatus_IsValid(int value) {
    return VehiclePosition_VehicleStopStatus_IsValid(value);
  }
  static constexpr VehicleStopStatus VehicleStopStatus_MIN =
    VehiclePosition_VehicleStopStatus_VehicleStopStatus_MIN;
  static constexpr VehicleStopStatus VehicleStopStatus_MAX =
    VehiclePosition_VehicleStopStatus_VehicleStopStatus_MAX;
  static constexpr int VehicleStopStatus_ARRAYSIZE =
    VehiclePosition_VehicleStopStatus_VehicleStopStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  VehicleStopStatus_descriptor() {
    return VehiclePosition_VehicleStopStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& VehicleStopStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VehicleStopStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VehicleStopStatus_Name.");
    return VehiclePosition_VehicleStopStatus_Name(enum_t_value);
  }
  static inline bool VehicleStopStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      VehicleStopStatus* value) {
    return VehiclePosition_VehicleStopStatus_Parse(name, value);
  }

  typedef VehiclePosition_CongestionLevel CongestionLevel;
  static constexpr CongestionLevel UNKNOWN_CONGESTION_LEVEL =
    VehiclePosition_CongestionLevel_UNKNOWN_CONGESTION_LEVEL;
  static constexpr CongestionLevel RUNNING_SMOOTHLY =
    VehiclePosition_CongestionLevel_RUNNING_SMOOTHLY;
  static constexpr CongestionLevel STOP_AND_GO =
    VehiclePosition_CongestionLevel_STOP_AND_GO;
  static constexpr CongestionLevel CONGESTION =
    VehiclePosition_CongestionLevel_CONGESTION;
  static constexpr CongestionLevel SEVERE_CONGESTION =
    VehiclePosition_CongestionLevel_SEVERE_CONGESTION;
  static inline bool CongestionLevel_IsValid(int value) {
    return VehiclePosition_CongestionLevel_IsValid(value);
  }
  static constexpr CongestionLevel CongestionLevel_MIN =
    VehiclePosition_CongestionLevel_CongestionLevel_MIN;
  static constexpr CongestionLevel CongestionLevel_MAX =
    VehiclePosition_CongestionLevel_CongestionLevel_MAX;
  static constexpr int CongestionLevel_ARRAYSIZE =
    VehiclePosition_CongestionLevel_CongestionLevel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CongestionLevel_descriptor() {
    return VehiclePosition_CongestionLevel_descriptor();
  }
  template<typename T>
  static inline const std::string& CongestionLevel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CongestionLevel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CongestionLevel_Name.");
    return VehiclePosition_CongestionLevel_Name(enum_t_value);
  }
  static inline bool CongestionLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CongestionLevel* value) {
    return VehiclePosition_CongestionLevel_Parse(name, value);
  }

  typedef VehiclePosition_OccupancyStatus OccupancyStatus;
  static constexpr OccupancyStatus EMPTY =
    VehiclePosition_OccupancyStatus_EMPTY;
  static constexpr OccupancyStatus MANY_SEATS_AVAILABLE =
    VehiclePosition_OccupancyStatus_MANY_SEATS_AVAILABLE;
  static constexpr OccupancyStatus FEW_SEATS_AVAILABLE =
    VehiclePosition_OccupancyStatus_FEW_SEATS_AVAILABLE;
  static constexpr OccupancyStatus STANDING_ROOM_ONLY =
    VehiclePosition_OccupancyStatus_STANDING_ROOM_ONLY;
  static constexpr OccupancyStatus CRUSHED_STANDING_ROOM_ONLY =
    VehiclePosition_OccupancyStatus_CRUSHED_STANDING_ROOM_ONLY;
  static constexpr OccupancyStatus FULL =
    VehiclePosition_OccupancyStatus_FULL;
  static constexpr OccupancyStatus NOT_ACCEPTING_PASSENGERS =
    VehiclePosition_OccupancyStatus_NOT_ACCEPTING_PASSENGERS;
  static constexpr OccupancyStatus NO_DATA_AVAILABLE =
    VehiclePosition_OccupancyStatus_NO_DATA_AVAILABLE;
  static constexpr OccupancyStatus NOT_BOARDABLE =
    VehiclePosition_OccupancyStatus_NOT_BOARDABLE;
  static inline bool OccupancyStatus_IsValid(int value) {
    return VehiclePosition_OccupancyStatus_IsValid(value);
  }
  static constexpr OccupancyStatus OccupancyStatus_MIN =
    VehiclePosition_OccupancyStatus_OccupancyStatus_MIN;
  static constexpr OccupancyStatus OccupancyStatus_MAX =
    VehiclePosition_OccupancyStatus_OccupancyStatus_MAX;
  static constexpr int OccupancyStatus_ARRAYSIZE =
    VehiclePosition_OccupancyStatus_OccupancyStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  OccupancyStatus_descriptor() {
    return VehiclePosition_OccupancyStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& OccupancyStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OccupancyStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OccupancyStatus_Name.");
    return VehiclePosition_OccupancyStatus_Name(enum_t_value);
  }
  static inline bool OccupancyStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      OccupancyStatus* value) {
    return VehiclePosition_OccupancyStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMultiCarriageDetailsFieldNumber = 11,
    kStopIdFieldNumber = 7,
    kTripFieldNumber = 1,
    kPositionFieldNumber = 2,
    kVehicleFieldNumber = 8,
    kCurrentStopSequenceFieldNumber = 3,
    kCongestionLevelFieldNumber = 6,
    kTimestampFieldNumber = 5,
    kOccupancyStatusFieldNumber = 9,
    kOccupancyPercentageFieldNumber = 10,
    kCurrentStatusFieldNumber = 4,
  };
  // repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;
  int multi_carriage_details_size() const;
  private:
  int _internal_multi_carriage_details_size() const;
  public:
  void clear_multi_carriage_details();
  ::transit_realtime::VehiclePosition_CarriageDetails* mutable_multi_carriage_details(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::VehiclePosition_CarriageDetails >*
      mutable_multi_carriage_details();
  private:
  const ::transit_realtime::VehiclePosition_CarriageDetails& _internal_multi_carriage_details(int index) const;
  ::transit_realtime::VehiclePosition_CarriageDetails* _internal_add_multi_carriage_details();
  public:
  const ::transit_realtime::VehiclePosition_CarriageDetails& multi_carriage_details(int index) const;
  ::transit_realtime::VehiclePosition_CarriageDetails* add_multi_carriage_details();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::VehiclePosition_CarriageDetails >&
      multi_carriage_details() const;

  // optional string stop_id = 7;
  bool has_stop_id() const;
  private:
  bool _internal_has_stop_id() const;
  public:
  void clear_stop_id();
  const std::string& stop_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stop_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stop_id();
  PROTOBUF_NODISCARD std::string* release_stop_id();
  void set_allocated_stop_id(std::string* stop_id);
  private:
  const std::string& _internal_stop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_id(const std::string& value);
  std::string* _internal_mutable_stop_id();
  public:

  // optional .transit_realtime.TripDescriptor trip = 1;
  bool has_trip() const;
  private:
  bool _internal_has_trip() const;
  public:
  void clear_trip();
  const ::transit_realtime::TripDescriptor& trip() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripDescriptor* release_trip();
  ::transit_realtime::TripDescriptor* mutable_trip();
  void set_allocated_trip(::transit_realtime::TripDescriptor* trip);
  private:
  const ::transit_realtime::TripDescriptor& _internal_trip() const;
  ::transit_realtime::TripDescriptor* _internal_mutable_trip();
  public:
  void unsafe_arena_set_allocated_trip(
      ::transit_realtime::TripDescriptor* trip);
  ::transit_realtime::TripDescriptor* unsafe_arena_release_trip();

  // optional .transit_realtime.Position position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::transit_realtime::Position& position() const;
  PROTOBUF_NODISCARD ::transit_realtime::Position* release_position();
  ::transit_realtime::Position* mutable_position();
  void set_allocated_position(::transit_realtime::Position* position);
  private:
  const ::transit_realtime::Position& _internal_position() const;
  ::transit_realtime::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::transit_realtime::Position* position);
  ::transit_realtime::Position* unsafe_arena_release_position();

  // optional .transit_realtime.VehicleDescriptor vehicle = 8;
  bool has_vehicle() const;
  private:
  bool _internal_has_vehicle() const;
  public:
  void clear_vehicle();
  const ::transit_realtime::VehicleDescriptor& vehicle() const;
  PROTOBUF_NODISCARD ::transit_realtime::VehicleDescriptor* release_vehicle();
  ::transit_realtime::VehicleDescriptor* mutable_vehicle();
  void set_allocated_vehicle(::transit_realtime::VehicleDescriptor* vehicle);
  private:
  const ::transit_realtime::VehicleDescriptor& _internal_vehicle() const;
  ::transit_realtime::VehicleDescriptor* _internal_mutable_vehicle();
  public:
  void unsafe_arena_set_allocated_vehicle(
      ::transit_realtime::VehicleDescriptor* vehicle);
  ::transit_realtime::VehicleDescriptor* unsafe_arena_release_vehicle();

  // optional uint32 current_stop_sequence = 3;
  bool has_current_stop_sequence() const;
  private:
  bool _internal_has_current_stop_sequence() const;
  public:
  void clear_current_stop_sequence();
  uint32_t current_stop_sequence() const;
  void set_current_stop_sequence(uint32_t value);
  private:
  uint32_t _internal_current_stop_sequence() const;
  void _internal_set_current_stop_sequence(uint32_t value);
  public:

  // optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;
  bool has_congestion_level() const;
  private:
  bool _internal_has_congestion_level() const;
  public:
  void clear_congestion_level();
  ::transit_realtime::VehiclePosition_CongestionLevel congestion_level() const;
  void set_congestion_level(::transit_realtime::VehiclePosition_CongestionLevel value);
  private:
  ::transit_realtime::VehiclePosition_CongestionLevel _internal_congestion_level() const;
  void _internal_set_congestion_level(::transit_realtime::VehiclePosition_CongestionLevel value);
  public:

  // optional uint64 timestamp = 5;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;
  bool has_occupancy_status() const;
  private:
  bool _internal_has_occupancy_status() const;
  public:
  void clear_occupancy_status();
  ::transit_realtime::VehiclePosition_OccupancyStatus occupancy_status() const;
  void set_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value);
  private:
  ::transit_realtime::VehiclePosition_OccupancyStatus _internal_occupancy_status() const;
  void _internal_set_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value);
  public:

  // optional uint32 occupancy_percentage = 10;
  bool has_occupancy_percentage() const;
  private:
  bool _internal_has_occupancy_percentage() const;
  public:
  void clear_occupancy_percentage();
  uint32_t occupancy_percentage() const;
  void set_occupancy_percentage(uint32_t value);
  private:
  uint32_t _internal_occupancy_percentage() const;
  void _internal_set_occupancy_percentage(uint32_t value);
  public:

  // optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];
  bool has_current_status() const;
  private:
  bool _internal_has_current_status() const;
  public:
  void clear_current_status();
  ::transit_realtime::VehiclePosition_VehicleStopStatus current_status() const;
  void set_current_status(::transit_realtime::VehiclePosition_VehicleStopStatus value);
  private:
  ::transit_realtime::VehiclePosition_VehicleStopStatus _internal_current_status() const;
  void _internal_set_current_status(::transit_realtime::VehiclePosition_VehicleStopStatus value);
  public:


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              VehiclePosition, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehiclePosition, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:transit_realtime.VehiclePosition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::VehiclePosition_CarriageDetails > multi_carriage_details_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_id_;
    ::transit_realtime::TripDescriptor* trip_;
    ::transit_realtime::Position* position_;
    ::transit_realtime::VehicleDescriptor* vehicle_;
    uint32_t current_stop_sequence_;
    int congestion_level_;
    uint64_t timestamp_;
    int occupancy_status_;
    uint32_t occupancy_percentage_;
    int current_status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class Alert final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.Alert) */ {
 public:
  inline Alert() : Alert(nullptr) {}
  ~Alert() override;
  explicit PROTOBUF_CONSTEXPR Alert(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Alert(const Alert& from);
  Alert(Alert&& from) noexcept
    : Alert() {
    *this = ::std::move(from);
  }

  inline Alert& operator=(const Alert& from) {
    CopyFrom(from);
    return *this;
  }
  inline Alert& operator=(Alert&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Alert& default_instance() {
    return *internal_default_instance();
  }
  static inline const Alert* internal_default_instance() {
    return reinterpret_cast<const Alert*>(
               &_Alert_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Alert& a, Alert& b) {
    a.Swap(&b);
  }
  inline void Swap(Alert* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Alert* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Alert* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Alert>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Alert& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Alert& from) {
    Alert::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Alert* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_realtime.Alert";
  }
  protected:
  explicit Alert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Alert_Cause Cause;
  static constexpr Cause UNKNOWN_CAUSE =
    Alert_Cause_UNKNOWN_CAUSE;
  static constexpr Cause OTHER_CAUSE =
    Alert_Cause_OTHER_CAUSE;
  static constexpr Cause TECHNICAL_PROBLEM =
    Alert_Cause_TECHNICAL_PROBLEM;
  static constexpr Cause STRIKE =
    Alert_Cause_STRIKE;
  static constexpr Cause DEMONSTRATION =
    Alert_Cause_DEMONSTRATION;
  static constexpr Cause ACCIDENT =
    Alert_Cause_ACCIDENT;
  static constexpr Cause HOLIDAY =
    Alert_Cause_HOLIDAY;
  static constexpr Cause WEATHER =
    Alert_Cause_WEATHER;
  static constexpr Cause MAINTENANCE =
    Alert_Cause_MAINTENANCE;
  static constexpr Cause CONSTRUCTION =
    Alert_Cause_CONSTRUCTION;
  static constexpr Cause POLICE_ACTIVITY =
    Alert_Cause_POLICE_ACTIVITY;
  static constexpr Cause MEDICAL_EMERGENCY =
    Alert_Cause_MEDICAL_EMERGENCY;
  static inline bool Cause_IsValid(int value) {
    return Alert_Cause_IsValid(value);
  }
  static constexpr Cause Cause_MIN =
    Alert_Cause_Cause_MIN;
  static constexpr Cause Cause_MAX =
    Alert_Cause_Cause_MAX;
  static constexpr int Cause_ARRAYSIZE =
    Alert_Cause_Cause_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Cause_descriptor() {
    return Alert_Cause_descriptor();
  }
  template<typename T>
  static inline const std::string& Cause_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Cause>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Cause_Name.");
    return Alert_Cause_Name(enum_t_value);
  }
  static inline bool Cause_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Cause* value) {
    return Alert_Cause_Parse(name, value);
  }

  typedef Alert_Effect Effect;
  static constexpr Effect NO_SERVICE =
    Alert_Effect_NO_SERVICE;
  static constexpr Effect REDUCED_SERVICE =
    Alert_Effect_REDUCED_SERVICE;
  static constexpr Effect SIGNIFICANT_DELAYS =
    Alert_Effect_SIGNIFICANT_DELAYS;
  static constexpr Effect DETOUR =
    Alert_Effect_DETOUR;
  static constexpr Effect ADDITIONAL_SERVICE =
    Alert_Effect_ADDITIONAL_SERVICE;
  static constexpr Effect MODIFIED_SERVICE =
    Alert_Effect_MODIFIED_SERVICE;
  static constexpr Effect OTHER_EFFECT =
    Alert_Effect_OTHER_EFFECT;
  static constexpr Effect UNKNOWN_EFFECT =
    Alert_Effect_UNKNOWN_EFFECT;
  static constexpr Effect STOP_MOVED =
    Alert_Effect_STOP_MOVED;
  static constexpr Effect NO_EFFECT =
    Alert_Effect_NO_EFFECT;
  static constexpr Effect ACCESSIBILITY_ISSUE =
    Alert_Effect_ACCESSIBILITY_ISSUE;
  static inline bool Effect_IsValid(int value) {
    return Alert_Effect_IsValid(value);
  }
  static constexpr Effect Effect_MIN =
    Alert_Effect_Effect_MIN;
  static constexpr Effect Effect_MAX =
    Alert_Effect_Effect_MAX;
  static constexpr int Effect_ARRAYSIZE =
    Alert_Effect_Effect_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Effect_descriptor() {
    return Alert_Effect_descriptor();
  }
  template<typename T>
  static inline const std::string& Effect_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Effect>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Effect_Name.");
    return Alert_Effect_Name(enum_t_value);
  }
  static inline bool Effect_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Effect* value) {
    return Alert_Effect_Parse(name, value);
  }

  typedef Alert_SeverityLevel SeverityLevel;
  static constexpr SeverityLevel UNKNOWN_SEVERITY =
    Alert_SeverityLevel_UNKNOWN_SEVERITY;
  static constexpr SeverityLevel INFO =
    Alert_SeverityLevel_INFO;
  static constexpr SeverityLevel WARNING =
    Alert_SeverityLevel_WARNING;
  static constexpr SeverityLevel SEVERE =
    Alert_SeverityLevel_SEVERE;
  static inline bool SeverityLevel_IsValid(int value) {
    return Alert_SeverityLevel_IsValid(value);
  }
  static constexpr SeverityLevel SeverityLevel_MIN =
    Alert_SeverityLevel_SeverityLevel_MIN;
  static constexpr SeverityLevel SeverityLevel_MAX =
    Alert_SeverityLevel_SeverityLevel_MAX;
  static constexpr int SeverityLevel_ARRAYSIZE =
    Alert_SeverityLevel_SeverityLevel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SeverityLevel_descriptor() {
    return Alert_SeverityLevel_descriptor();
  }
  template<typename T>
  static inline const std::string& SeverityLevel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SeverityLevel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SeverityLevel_Name.");
    return Alert_SeverityLevel_Name(enum_t_value);
  }
  static inline bool SeverityLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SeverityLevel* value) {
    return Alert_SeverityLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kActivePeriodFieldNumber = 1,
    kInformedEntityFieldNumber = 5,
    kUrlFieldNumber = 8,
    kHeaderTextFieldNumber = 10,
    kDescriptionTextFieldNumber = 11,
    kTtsHeaderTextFieldNumber = 12,
    kTtsDescriptionTextFieldNumber = 13,
    kImageFieldNumber = 15,
    kImageAlternativeTextFieldNumber = 16,
    kSeverityLevelFieldNumber = 14,
    kCauseFieldNumber = 6,
    kEffectFieldNumber = 7,
  };
  // repeated .transit_realtime.TimeRange active_period = 1;
  int active_period_size() const;
  private:
  int _internal_active_period_size() const;
  public:
  void clear_active_period();
  ::transit_realtime::TimeRange* mutable_active_period(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TimeRange >*
      mutable_active_period();
  private:
  const ::transit_realtime::TimeRange& _internal_active_period(int index) const;
  ::transit_realtime::TimeRange* _internal_add_active_period();
  public:
  const ::transit_realtime::TimeRange& active_period(int index) const;
  ::transit_realtime::TimeRange* add_active_period();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TimeRange >&
      active_period() const;

  // repeated .transit_realtime.EntitySelector informed_entity = 5;
  int informed_entity_size() const;
  private:
  int _internal_informed_entity_size() const;
  public:
  void clear_informed_entity();
  ::transit_realtime::EntitySelector* mutable_informed_entity(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::EntitySelector >*
      mutable_informed_entity();
  private:
  const ::transit_realtime::EntitySelector& _internal_informed_entity(int index) const;
  ::transit_realtime::EntitySelector* _internal_add_informed_entity();
  public:
  const ::transit_realtime::EntitySelector& informed_entity(int index) const;
  ::transit_realtime::EntitySelector* add_informed_entity();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::EntitySelector >&
      informed_entity() const;

  // optional .transit_realtime.TranslatedString url = 8;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const ::transit_realtime::TranslatedString& url() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_url();
  ::transit_realtime::TranslatedString* mutable_url();
  void set_allocated_url(::transit_realtime::TranslatedString* url);
  private:
  const ::transit_realtime::TranslatedString& _internal_url() const;
  ::transit_realtime::TranslatedString* _internal_mutable_url();
  public:
  void unsafe_arena_set_allocated_url(
      ::transit_realtime::TranslatedString* url);
  ::transit_realtime::TranslatedString* unsafe_arena_release_url();

  // optional .transit_realtime.TranslatedString header_text = 10;
  bool has_header_text() const;
  private:
  bool _internal_has_header_text() const;
  public:
  void clear_header_text();
  const ::transit_realtime::TranslatedString& header_text() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_header_text();
  ::transit_realtime::TranslatedString* mutable_header_text();
  void set_allocated_header_text(::transit_realtime::TranslatedString* header_text);
  private:
  const ::transit_realtime::TranslatedString& _internal_header_text() const;
  ::transit_realtime::TranslatedString* _internal_mutable_header_text();
  public:
  void unsafe_arena_set_allocated_header_text(
      ::transit_realtime::TranslatedString* header_text);
  ::transit_realtime::TranslatedString* unsafe_arena_release_header_text();

  // optional .transit_realtime.TranslatedString description_text = 11;
  bool has_description_text() const;
  private:
  bool _internal_has_description_text() const;
  public:
  void clear_description_text();
  const ::transit_realtime::TranslatedString& description_text() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_description_text();
  ::transit_realtime::TranslatedString* mutable_description_text();
  void set_allocated_description_text(::transit_realtime::TranslatedString* description_text);
  private:
  const ::transit_realtime::TranslatedString& _internal_description_text() const;
  ::transit_realtime::TranslatedString* _internal_mutable_description_text();
  public:
  void unsafe_arena_set_allocated_description_text(
      ::transit_realtime::TranslatedString* description_text);
  ::transit_realtime::TranslatedString* unsafe_arena_release_description_text();

  // optional .transit_realtime.TranslatedString tts_header_text = 12;
  bool has_tts_header_text() const;
  private:
  bool _internal_has_tts_header_text() const;
  public:
  void clear_tts_header_text();
  const ::transit_realtime::TranslatedString& tts_header_text() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_tts_header_text();
  ::transit_realtime::TranslatedString* mutable_tts_header_text();
  void set_allocated_tts_header_text(::transit_realtime::TranslatedString* tts_header_text);
  private:
  const ::transit_realtime::TranslatedString& _internal_tts_header_text() const;
  ::transit_realtime::TranslatedString* _internal_mutable_tts_header_text();
  public:
  void unsafe_arena_set_allocated_tts_header_text(
      ::transit_realtime::TranslatedString* tts_header_text);
  ::transit_realtime::TranslatedString* unsafe_arena_release_tts_header_text();

  // optional .transit_realtime.TranslatedString tts_description_text = 13;
  bool has_tts_description_text() const;
  private:
  bool _internal_has_tts_description_text() const;
  public:
  void clear_tts_description_text();
  const ::transit_realtime::TranslatedString& tts_description_text() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_tts_description_text();
  ::transit_realtime::TranslatedString* mutable_tts_description_text();
  void set_allocated_tts_description_text(::transit_realtime::TranslatedString* tts_description_text);
  private:
  const ::transit_realtime::TranslatedString& _internal_tts_description_text() const;
  ::transit_realtime::TranslatedString* _internal_mutable_tts_description_text();
  public:
  void unsafe_arena_set_allocated_tts_description_text(
      ::transit_realtime::TranslatedString* tts_description_text);
  ::transit_realtime::TranslatedString* unsafe_arena_release_tts_description_text();

  // optional .transit_realtime.TranslatedImage image = 15;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::transit_realtime::TranslatedImage& image() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedImage* release_image();
  ::transit_realtime::TranslatedImage* mutable_image();
  void set_allocated_image(::transit_realtime::TranslatedImage* image);
  private:
  const ::transit_realtime::TranslatedImage& _internal_image() const;
  ::transit_realtime::TranslatedImage* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::transit_realtime::TranslatedImage* image);
  ::transit_realtime::TranslatedImage* unsafe_arena_release_image();

  // optional .transit_realtime.TranslatedString image_alternative_text = 16;
  bool has_image_alternative_text() const;
  private:
  bool _internal_has_image_alternative_text() const;
  public:
  void clear_image_alternative_text();
  const ::transit_realtime::TranslatedString& image_alternative_text() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_image_alternative_text();
  ::transit_realtime::TranslatedString* mutable_image_alternative_text();
  void set_allocated_image_alternative_text(::transit_realtime::TranslatedString* image_alternative_text);
  private:
  const ::transit_realtime::TranslatedString& _internal_image_alternative_text() const;
  ::transit_realtime::TranslatedString* _internal_mutable_image_alternative_text();
  public:
  void unsafe_arena_set_allocated_image_alternative_text(
      ::transit_realtime::TranslatedString* image_alternative_text);
  ::transit_realtime::TranslatedString* unsafe_arena_release_image_alternative_text();

  // optional .transit_realtime.Alert.SeverityLevel severity_level = 14 [default = UNKNOWN_SEVERITY];
  bool has_severity_level() const;
  private:
  bool _internal_has_severity_level() const;
  public:
  void clear_severity_level();
  ::transit_realtime::Alert_SeverityLevel severity_level() const;
  void set_severity_level(::transit_realtime::Alert_SeverityLevel value);
  private:
  ::transit_realtime::Alert_SeverityLevel _internal_severity_level() const;
  void _internal_set_severity_level(::transit_realtime::Alert_SeverityLevel value);
  public:

  // optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];
  bool has_cause() const;
  private:
  bool _internal_has_cause() const;
  public:
  void clear_cause();
  ::transit_realtime::Alert_Cause cause() const;
  void set_cause(::transit_realtime::Alert_Cause value);
  private:
  ::transit_realtime::Alert_Cause _internal_cause() const;
  void _internal_set_cause(::transit_realtime::Alert_Cause value);
  public:

  // optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];
  bool has_effect() const;
  private:
  bool _internal_has_effect() const;
  public:
  void clear_effect();
  ::transit_realtime::Alert_Effect effect() const;
  void set_effect(::transit_realtime::Alert_Effect value);
  private:
  ::transit_realtime::Alert_Effect _internal_effect() const;
  void _internal_set_effect(::transit_realtime::Alert_Effect value);
  public:


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Alert, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Alert, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Alert, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Alert, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Alert, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Alert, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Alert, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Alert, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              Alert, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Alert, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Alert, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Alert, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Alert, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Alert, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Alert, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Alert, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Alert, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:transit_realtime.Alert)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TimeRange > active_period_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::EntitySelector > informed_entity_;
    ::transit_realtime::TranslatedString* url_;
    ::transit_realtime::TranslatedString* header_text_;
    ::transit_realtime::TranslatedString* description_text_;
    ::transit_realtime::TranslatedString* tts_header_text_;
    ::transit_realtime::TranslatedString* tts_description_text_;
    ::transit_realtime::TranslatedImage* image_;
    ::transit_realtime::TranslatedString* image_alternative_text_;
    int severity_level_;
    int cause_;
    int effect_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TimeRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TimeRange) */ {
 public:
  inline TimeRange() : TimeRange(nullptr) {}
  ~TimeRange() override;
  explicit PROTOBUF_CONSTEXPR TimeRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeRange(const TimeRange& from);
  TimeRange(TimeRange&& from) noexcept
    : TimeRange() {
    *this = ::std::move(from);
  }

  inline TimeRange& operator=(const TimeRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeRange& operator=(TimeRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeRange* internal_default_instance() {
    return reinterpret_cast<const TimeRange*>(
               &_TimeRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TimeRange& a, TimeRange& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimeRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimeRange& from) {
    TimeRange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_realtime.TimeRange";
  }
  protected:
  explicit TimeRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // optional uint64 start = 1;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  uint64_t start() const;
  void set_start(uint64_t value);
  private:
  uint64_t _internal_start() const;
  void _internal_set_start(uint64_t value);
  public:

  // optional uint64 end = 2;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  uint64_t end() const;
  void set_end(uint64_t value);
  private:
  uint64_t _internal_end() const;
  void _internal_set_end(uint64_t value);
  public:


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TimeRange, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TimeRange, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TimeRange, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TimeRange, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TimeRange, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TimeRange, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TimeRange, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TimeRange, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              TimeRange, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TimeRange, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TimeRange, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TimeRange, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TimeRange, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TimeRange, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TimeRange, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TimeRange, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TimeRange, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:transit_realtime.TimeRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t start_;
    uint64_t end_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class Position final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() override;
  explicit PROTOBUF_CONSTEXPR Position(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Position& from) {
    Position::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_realtime.Position";
  }
  protected:
  explicit Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatitudeFieldNumber = 1,
    kLongitudeFieldNumber = 2,
    kOdometerFieldNumber = 4,
    kBearingFieldNumber = 3,
    kSpeedFieldNumber = 5,
  };
  // required float latitude = 1;
  bool has_latitude() const;
  private:
  bool _internal_has_latitude() const;
  public:
  void clear_latitude();
  float latitude() const;
  void set_latitude(float value);
  private:
  float _internal_latitude() const;
  void _internal_set_latitude(float value);
  public:

  // required float longitude = 2;
  bool has_longitude() const;
  private:
  bool _internal_has_longitude() const;
  public:
  void clear_longitude();
  float longitude() const;
  void set_longitude(float value);
  private:
  float _internal_longitude() const;
  void _internal_set_longitude(float value);
  public:

  // optional double odometer = 4;
  bool has_odometer() const;
  private:
  bool _internal_has_odometer() const;
  public:
  void clear_odometer();
  double odometer() const;
  void set_odometer(double value);
  private:
  double _internal_odometer() const;
  void _internal_set_odometer(double value);
  public:

  // optional float bearing = 3;
  bool has_bearing() const;
  private:
  bool _internal_has_bearing() const;
  public:
  void clear_bearing();
  float bearing() const;
  void set_bearing(float value);
  private:
  float _internal_bearing() const;
  void _internal_set_bearing(float value);
  public:

  // optional float speed = 5;
  bool has_speed() const;
  private:
  bool _internal_has_speed() const;
  public:
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Position, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Position, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Position, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Position, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Position, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Position, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Position, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Position, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              Position, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Position, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Position, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Position, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Position, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Position, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Position, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Position, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Position, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:transit_realtime.Position)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float latitude_;
    float longitude_;
    double odometer_;
    float bearing_;
    float speed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TripDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TripDescriptor) */ {
 public:
  inline TripDescriptor() : TripDescriptor(nullptr) {}
  ~TripDescriptor() override;
  explicit PROTOBUF_CONSTEXPR TripDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TripDescriptor(const TripDescriptor& from);
  TripDescriptor(TripDescriptor&& from) noexcept
    : TripDescriptor() {
    *this = ::std::move(from);
  }

  inline TripDescriptor& operator=(const TripDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripDescriptor& operator=(TripDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripDescriptor* internal_default_instance() {
    return reinterpret_cast<const TripDescriptor*>(
               &_TripDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TripDescriptor& a, TripDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(TripDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TripDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TripDescriptor& from) {
    TripDescriptor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TripDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_realtime.TripDescriptor";
  }
  protected:
  explicit TripDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TripDescriptor_ScheduleRelationship ScheduleRelationship;
  static constexpr ScheduleRelationship SCHEDULED =
    TripDescriptor_ScheduleRelationship_SCHEDULED;
  static constexpr ScheduleRelationship ADDED =
    TripDescriptor_ScheduleRelationship_ADDED;
  static constexpr ScheduleRelationship UNSCHEDULED =
    TripDescriptor_ScheduleRelationship_UNSCHEDULED;
  static constexpr ScheduleRelationship CANCELED =
    TripDescriptor_ScheduleRelationship_CANCELED;
  PROTOBUF_DEPRECATED_ENUM static constexpr ScheduleRelationship REPLACEMENT =
    TripDescriptor_ScheduleRelationship_REPLACEMENT;
  static constexpr ScheduleRelationship DUPLICATED =
    TripDescriptor_ScheduleRelationship_DUPLICATED;
  static inline bool ScheduleRelationship_IsValid(int value) {
    return TripDescriptor_ScheduleRelationship_IsValid(value);
  }
  static constexpr ScheduleRelationship ScheduleRelationship_MIN =
    TripDescriptor_ScheduleRelationship_ScheduleRelationship_MIN;
  static constexpr ScheduleRelationship ScheduleRelationship_MAX =
    TripDescriptor_ScheduleRelationship_ScheduleRelationship_MAX;
  static constexpr int ScheduleRelationship_ARRAYSIZE =
    TripDescriptor_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ScheduleRelationship_descriptor() {
    return TripDescriptor_ScheduleRelationship_descriptor();
  }
  template<typename T>
  static inline const std::string& ScheduleRelationship_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScheduleRelationship>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScheduleRelationship_Name.");
    return TripDescriptor_ScheduleRelationship_Name(enum_t_value);
  }
  static inline bool ScheduleRelationship_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ScheduleRelationship* value) {
    return TripDescriptor_ScheduleRelationship_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTripIdFieldNumber = 1,
    kStartTimeFieldNumber = 2,
    kStartDateFieldNumber = 3,
    kRouteIdFieldNumber = 5,
    kScheduleRelationshipFieldNumber = 4,
    kDirectionIdFieldNumber = 6,
  };
  // optional string trip_id = 1;
  bool has_trip_id() const;
  private:
  bool _internal_has_trip_id() const;
  public:
  void clear_trip_id();
  const std::string& trip_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trip_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trip_id();
  PROTOBUF_NODISCARD std::string* release_trip_id();
  void set_allocated_trip_id(std::string* trip_id);
  private:
  const std::string& _internal_trip_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trip_id(const std::string& value);
  std::string* _internal_mutable_trip_id();
  public:

  // optional string start_time = 2;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const std::string& start_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_time();
  PROTOBUF_NODISCARD std::string* release_start_time();
  void set_allocated_start_time(std::string* start_time);
  private:
  const std::string& _internal_start_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_time(const std::string& value);
  std::string* _internal_mutable_start_time();
  public:

  // optional string start_date = 3;
  bool has_start_date() const;
  private:
  bool _internal_has_start_date() const;
  public:
  void clear_start_date();
  const std::string& start_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_date();
  PROTOBUF_NODISCARD std::string* release_start_date();
  void set_allocated_start_date(std::string* start_date);
  private:
  const std::string& _internal_start_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_date(const std::string& value);
  std::string* _internal_mutable_start_date();
  public:

  // optional string route_id = 5;
  bool has_route_id() const;
  private:
  bool _internal_has_route_id() const;
  public:
  void clear_route_id();
  const std::string& route_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_route_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_route_id();
  PROTOBUF_NODISCARD std::string* release_route_id();
  void set_allocated_route_id(std::string* route_id);
  private:
  const std::string& _internal_route_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route_id(const std::string& value);
  std::string* _internal_mutable_route_id();
  public:

  // optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;
  bool has_schedule_relationship() const;
  private:
  bool _internal_has_schedule_relationship() const;
  public:
  void clear_schedule_relationship();
  ::transit_realtime::TripDescriptor_ScheduleRelationship schedule_relationship() const;
  void set_schedule_relationship(::transit_realtime::TripDescriptor_ScheduleRelationship value);
  private:
  ::transit_realtime::TripDescriptor_ScheduleRelationship _internal_schedule_relationship() const;
  void _internal_set_schedule_relationship(::transit_realtime::TripDescriptor_ScheduleRelationship value);
  public:

  // optional uint32 direction_id = 6;
  bool has_direction_id() const;
  private:
  bool _internal_has_direction_id() const;
  public:
  void clear_direction_id();
  uint32_t direction_id() const;
  void set_direction_id(uint32_t value);
  private:
  uint32_t _internal_direction_id() const;
  void _internal_set_direction_id(uint32_t value);
  public:


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              TripDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TripDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:transit_realtime.TripDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trip_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_date_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr route_id_;
    int schedule_relationship_;
    uint32_t direction_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class VehicleDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.VehicleDescriptor) */ {
 public:
  inline VehicleDescriptor() : VehicleDescriptor(nullptr) {}
  ~VehicleDescriptor() override;
  explicit PROTOBUF_CONSTEXPR VehicleDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VehicleDescriptor(const VehicleDescriptor& from);
  VehicleDescriptor(VehicleDescriptor&& from) noexcept
    : VehicleDescriptor() {
    *this = ::std::move(from);
  }

  inline VehicleDescriptor& operator=(const VehicleDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleDescriptor& operator=(VehicleDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehicleDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehicleDescriptor* internal_default_instance() {
    return reinterpret_cast<const VehicleDescriptor*>(
               &_VehicleDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(VehicleDescriptor& a, VehicleDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehicleDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehicleDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VehicleDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VehicleDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VehicleDescriptor& from) {
    VehicleDescriptor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_realtime.VehicleDescriptor";
  }
  protected:
  explicit VehicleDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kLabelFieldNumber = 2,
    kLicensePlateFieldNumber = 3,
  };
  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string label = 2;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // optional string license_plate = 3;
  bool has_license_plate() const;
  private:
  bool _internal_has_license_plate() const;
  public:
  void clear_license_plate();
  const std::string& license_plate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_license_plate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_license_plate();
  PROTOBUF_NODISCARD std::string* release_license_plate();
  void set_allocated_license_plate(std::string* license_plate);
  private:
  const std::string& _internal_license_plate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_license_plate(const std::string& value);
  std::string* _internal_mutable_license_plate();
  public:


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehicleDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehicleDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehicleDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehicleDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehicleDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehicleDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehicleDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehicleDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              VehicleDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehicleDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehicleDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehicleDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehicleDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehicleDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehicleDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehicleDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          VehicleDescriptor, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:transit_realtime.VehicleDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr license_plate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class EntitySelector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.EntitySelector) */ {
 public:
  inline EntitySelector() : EntitySelector(nullptr) {}
  ~EntitySelector() override;
  explicit PROTOBUF_CONSTEXPR EntitySelector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EntitySelector(const EntitySelector& from);
  EntitySelector(EntitySelector&& from) noexcept
    : EntitySelector() {
    *this = ::std::move(from);
  }

  inline EntitySelector& operator=(const EntitySelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntitySelector& operator=(EntitySelector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntitySelector& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntitySelector* internal_default_instance() {
    return reinterpret_cast<const EntitySelector*>(
               &_EntitySelector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(EntitySelector& a, EntitySelector& b) {
    a.Swap(&b);
  }
  inline void Swap(EntitySelector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntitySelector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntitySelector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EntitySelector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EntitySelector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EntitySelector& from) {
    EntitySelector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntitySelector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_realtime.EntitySelector";
  }
  protected:
  explicit EntitySelector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgencyIdFieldNumber = 1,
    kRouteIdFieldNumber = 2,
    kStopIdFieldNumber = 5,
    kTripFieldNumber = 4,
    kRouteTypeFieldNumber = 3,
    kDirectionIdFieldNumber = 6,
  };
  // optional string agency_id = 1;
  bool has_agency_id() const;
  private:
  bool _internal_has_agency_id() const;
  public:
  void clear_agency_id();
  const std::string& agency_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agency_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agency_id();
  PROTOBUF_NODISCARD std::string* release_agency_id();
  void set_allocated_agency_id(std::string* agency_id);
  private:
  const std::string& _internal_agency_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agency_id(const std::string& value);
  std::string* _internal_mutable_agency_id();
  public:

  // optional string route_id = 2;
  bool has_route_id() const;
  private:
  bool _internal_has_route_id() const;
  public:
  void clear_route_id();
  const std::string& route_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_route_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_route_id();
  PROTOBUF_NODISCARD std::string* release_route_id();
  void set_allocated_route_id(std::string* route_id);
  private:
  const std::string& _internal_route_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route_id(const std::string& value);
  std::string* _internal_mutable_route_id();
  public:

  // optional string stop_id = 5;
  bool has_stop_id() const;
  private:
  bool _internal_has_stop_id() const;
  public:
  void clear_stop_id();
  const std::string& stop_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stop_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stop_id();
  PROTOBUF_NODISCARD std::string* release_stop_id();
  void set_allocated_stop_id(std::string* stop_id);
  private:
  const std::string& _internal_stop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_id(const std::string& value);
  std::string* _internal_mutable_stop_id();
  public:

  // optional .transit_realtime.TripDescriptor trip = 4;
  bool has_trip() const;
  private:
  bool _internal_has_trip() const;
  public:
  void clear_trip();
  const ::transit_realtime::TripDescriptor& trip() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripDescriptor* release_trip();
  ::transit_realtime::TripDescriptor* mutable_trip();
  void set_allocated_trip(::transit_realtime::TripDescriptor* trip);
  private:
  const ::transit_realtime::TripDescriptor& _internal_trip() const;
  ::transit_realtime::TripDescriptor* _internal_mutable_trip();
  public:
  void unsafe_arena_set_allocated_trip(
      ::transit_realtime::TripDescriptor* trip);
  ::transit_realtime::TripDescriptor* unsafe_arena_release_trip();

  // optional int32 route_type = 3;
  bool has_route_type() const;
  private:
  bool _internal_has_route_type() const;
  public:
  void clear_route_type();
  int32_t route_type() const;
  void set_route_type(int32_t value);
  private:
  int32_t _internal_route_type() const;
  void _internal_set_route_type(int32_t value);
  public:

  // optional uint32 direction_id = 6;
  bool has_direction_id() const;
  private:
  bool _internal_has_direction_id() const;
  public:
  void clear_direction_id();
  uint32_t direction_id() const;
  void set_direction_id(uint32_t value);
  private:
  uint32_t _internal_direction_id() const;
  void _internal_set_direction_id(uint32_t value);
  public:


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          EntitySelector, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          EntitySelector, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          EntitySelector, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          EntitySelector, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          EntitySelector, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          EntitySelector, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          EntitySelector, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          EntitySelector, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              EntitySelector, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          EntitySelector, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          EntitySelector, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          EntitySelector, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          EntitySelector, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          EntitySelector, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          EntitySelector, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          EntitySelector, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          EntitySelector, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:transit_realtime.EntitySelector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agency_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr route_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_id_;
    ::transit_realtime::TripDescriptor* trip_;
    int32_t route_type_;
    uint32_t direction_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TranslatedString_Translation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TranslatedString.Translation) */ {
 public:
  inline TranslatedString_Translation() : TranslatedString_Translation(nullptr) {}
  ~TranslatedString_Translation() override;
  explicit PROTOBUF_CONSTEXPR TranslatedString_Translation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TranslatedString_Translation(const TranslatedString_Translation& from);
  TranslatedString_Translation(TranslatedString_Translation&& from) noexcept
    : TranslatedString_Translation() {
    *this = ::std::move(from);
  }

  inline TranslatedString_Translation& operator=(const TranslatedString_Translation& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranslatedString_Translation& operator=(TranslatedString_Translation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranslatedString_Translation& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranslatedString_Translation* internal_default_instance() {
    return reinterpret_cast<const TranslatedString_Translation*>(
               &_TranslatedString_Translation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TranslatedString_Translation& a, TranslatedString_Translation& b) {
    a.Swap(&b);
  }
  inline void Swap(TranslatedString_Translation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranslatedString_Translation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TranslatedString_Translation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TranslatedString_Translation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TranslatedString_Translation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TranslatedString_Translation& from) {
    TranslatedString_Translation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranslatedString_Translation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_realtime.TranslatedString.Translation";
  }
  protected:
  explicit TranslatedString_Translation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kLanguageFieldNumber = 2,
  };
  // required string text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // optional string language = 2;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString_Translation, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString_Translation, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString_Translation, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString_Translation, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString_Translation, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString_Translation, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString_Translation, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString_Translation, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              TranslatedString_Translation, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString_Translation, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString_Translation, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString_Translation, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString_Translation, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString_Translation, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString_Translation, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString_Translation, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString_Translation, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:transit_realtime.TranslatedString.Translation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TranslatedString final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TranslatedString) */ {
 public:
  inline TranslatedString() : TranslatedString(nullptr) {}
  ~TranslatedString() override;
  explicit PROTOBUF_CONSTEXPR TranslatedString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TranslatedString(const TranslatedString& from);
  TranslatedString(TranslatedString&& from) noexcept
    : TranslatedString() {
    *this = ::std::move(from);
  }

  inline TranslatedString& operator=(const TranslatedString& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranslatedString& operator=(TranslatedString&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranslatedString& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranslatedString* internal_default_instance() {
    return reinterpret_cast<const TranslatedString*>(
               &_TranslatedString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TranslatedString& a, TranslatedString& b) {
    a.Swap(&b);
  }
  inline void Swap(TranslatedString* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranslatedString* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TranslatedString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TranslatedString>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TranslatedString& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TranslatedString& from) {
    TranslatedString::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranslatedString* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_realtime.TranslatedString";
  }
  protected:
  explicit TranslatedString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TranslatedString_Translation Translation;

  // accessors -------------------------------------------------------

  enum : int {
    kTranslationFieldNumber = 1,
  };
  // repeated .transit_realtime.TranslatedString.Translation translation = 1;
  int translation_size() const;
  private:
  int _internal_translation_size() const;
  public:
  void clear_translation();
  ::transit_realtime::TranslatedString_Translation* mutable_translation(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation >*
      mutable_translation();
  private:
  const ::transit_realtime::TranslatedString_Translation& _internal_translation(int index) const;
  ::transit_realtime::TranslatedString_Translation* _internal_add_translation();
  public:
  const ::transit_realtime::TranslatedString_Translation& translation(int index) const;
  ::transit_realtime::TranslatedString_Translation* add_translation();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation >&
      translation() const;


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              TranslatedString, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedString, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:transit_realtime.TranslatedString)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation > translation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TranslatedImage_LocalizedImage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TranslatedImage.LocalizedImage) */ {
 public:
  inline TranslatedImage_LocalizedImage() : TranslatedImage_LocalizedImage(nullptr) {}
  ~TranslatedImage_LocalizedImage() override;
  explicit PROTOBUF_CONSTEXPR TranslatedImage_LocalizedImage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TranslatedImage_LocalizedImage(const TranslatedImage_LocalizedImage& from);
  TranslatedImage_LocalizedImage(TranslatedImage_LocalizedImage&& from) noexcept
    : TranslatedImage_LocalizedImage() {
    *this = ::std::move(from);
  }

  inline TranslatedImage_LocalizedImage& operator=(const TranslatedImage_LocalizedImage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranslatedImage_LocalizedImage& operator=(TranslatedImage_LocalizedImage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranslatedImage_LocalizedImage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranslatedImage_LocalizedImage* internal_default_instance() {
    return reinterpret_cast<const TranslatedImage_LocalizedImage*>(
               &_TranslatedImage_LocalizedImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(TranslatedImage_LocalizedImage& a, TranslatedImage_LocalizedImage& b) {
    a.Swap(&b);
  }
  inline void Swap(TranslatedImage_LocalizedImage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranslatedImage_LocalizedImage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TranslatedImage_LocalizedImage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TranslatedImage_LocalizedImage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TranslatedImage_LocalizedImage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TranslatedImage_LocalizedImage& from) {
    TranslatedImage_LocalizedImage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranslatedImage_LocalizedImage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_realtime.TranslatedImage.LocalizedImage";
  }
  protected:
  explicit TranslatedImage_LocalizedImage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kMediaTypeFieldNumber = 2,
    kLanguageFieldNumber = 3,
  };
  // required string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // required string media_type = 2;
  bool has_media_type() const;
  private:
  bool _internal_has_media_type() const;
  public:
  void clear_media_type();
  const std::string& media_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_media_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_media_type();
  PROTOBUF_NODISCARD std::string* release_media_type();
  void set_allocated_media_type(std::string* media_type);
  private:
  const std::string& _internal_media_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_media_type(const std::string& value);
  std::string* _internal_mutable_media_type();
  public:

  // optional string language = 3;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage_LocalizedImage, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage_LocalizedImage, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage_LocalizedImage, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage_LocalizedImage, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage_LocalizedImage, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage_LocalizedImage, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage_LocalizedImage, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage_LocalizedImage, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              TranslatedImage_LocalizedImage, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage_LocalizedImage, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage_LocalizedImage, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage_LocalizedImage, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage_LocalizedImage, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage_LocalizedImage, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage_LocalizedImage, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage_LocalizedImage, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage_LocalizedImage, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:transit_realtime.TranslatedImage.LocalizedImage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr media_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TranslatedImage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TranslatedImage) */ {
 public:
  inline TranslatedImage() : TranslatedImage(nullptr) {}
  ~TranslatedImage() override;
  explicit PROTOBUF_CONSTEXPR TranslatedImage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TranslatedImage(const TranslatedImage& from);
  TranslatedImage(TranslatedImage&& from) noexcept
    : TranslatedImage() {
    *this = ::std::move(from);
  }

  inline TranslatedImage& operator=(const TranslatedImage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranslatedImage& operator=(TranslatedImage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranslatedImage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranslatedImage* internal_default_instance() {
    return reinterpret_cast<const TranslatedImage*>(
               &_TranslatedImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(TranslatedImage& a, TranslatedImage& b) {
    a.Swap(&b);
  }
  inline void Swap(TranslatedImage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranslatedImage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TranslatedImage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TranslatedImage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TranslatedImage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TranslatedImage& from) {
    TranslatedImage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranslatedImage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_realtime.TranslatedImage";
  }
  protected:
  explicit TranslatedImage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TranslatedImage_LocalizedImage LocalizedImage;

  // accessors -------------------------------------------------------

  enum : int {
    kLocalizedImageFieldNumber = 1,
  };
  // repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;
  int localized_image_size() const;
  private:
  int _internal_localized_image_size() const;
  public:
  void clear_localized_image();
  ::transit_realtime::TranslatedImage_LocalizedImage* mutable_localized_image(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TranslatedImage_LocalizedImage >*
      mutable_localized_image();
  private:
  const ::transit_realtime::TranslatedImage_LocalizedImage& _internal_localized_image(int index) const;
  ::transit_realtime::TranslatedImage_LocalizedImage* _internal_add_localized_image();
  public:
  const ::transit_realtime::TranslatedImage_LocalizedImage& localized_image(int index) const;
  ::transit_realtime::TranslatedImage_LocalizedImage* add_localized_image();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TranslatedImage_LocalizedImage >&
      localized_image() const;


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              TranslatedImage, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          TranslatedImage, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:transit_realtime.TranslatedImage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TranslatedImage_LocalizedImage > localized_image_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class Shape final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transit_realtime.Shape) */ {
 public:
  inline Shape() : Shape(nullptr) {}
  ~Shape() override;
  explicit PROTOBUF_CONSTEXPR Shape(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Shape(const Shape& from);
  Shape(Shape&& from) noexcept
    : Shape() {
    *this = ::std::move(from);
  }

  inline Shape& operator=(const Shape& from) {
    CopyFrom(from);
    return *this;
  }
  inline Shape& operator=(Shape&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Shape& default_instance() {
    return *internal_default_instance();
  }
  static inline const Shape* internal_default_instance() {
    return reinterpret_cast<const Shape*>(
               &_Shape_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Shape& a, Shape& b) {
    a.Swap(&b);
  }
  inline void Swap(Shape* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Shape* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Shape* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Shape>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Shape& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Shape& from) {
    Shape::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Shape* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transit_realtime.Shape";
  }
  protected:
  explicit Shape(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeIdFieldNumber = 1,
    kEncodedPolylineFieldNumber = 2,
  };
  // optional string shape_id = 1;
  bool has_shape_id() const;
  private:
  bool _internal_has_shape_id() const;
  public:
  void clear_shape_id();
  const std::string& shape_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shape_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shape_id();
  PROTOBUF_NODISCARD std::string* release_shape_id();
  void set_allocated_shape_id(std::string* shape_id);
  private:
  const std::string& _internal_shape_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shape_id(const std::string& value);
  std::string* _internal_mutable_shape_id();
  public:

  // optional string encoded_polyline = 2;
  bool has_encoded_polyline() const;
  private:
  bool _internal_has_encoded_polyline() const;
  public:
  void clear_encoded_polyline();
  const std::string& encoded_polyline() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encoded_polyline(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encoded_polyline();
  PROTOBUF_NODISCARD std::string* release_encoded_polyline();
  void set_allocated_encoded_polyline(std::string* encoded_polyline);
  private:
  const std::string& _internal_encoded_polyline() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encoded_polyline(const std::string& value);
  std::string* _internal_mutable_encoded_polyline();
  public:


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Shape, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Shape, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Shape, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Shape, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Shape, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Shape, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Shape, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Shape, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              Shape, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Shape, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Shape, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Shape, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Shape, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Shape, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Shape, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Shape, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          Shape, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:transit_realtime.Shape)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shape_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoded_polyline_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FeedMessage

// required .transit_realtime.FeedHeader header = 1;
inline bool FeedMessage::_internal_has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline bool FeedMessage::has_header() const {
  return _internal_has_header();
}
inline void FeedMessage::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::transit_realtime::FeedHeader& FeedMessage::_internal_header() const {
  const ::transit_realtime::FeedHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::FeedHeader&>(
      ::transit_realtime::_FeedHeader_default_instance_);
}
inline const ::transit_realtime::FeedHeader& FeedMessage::header() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedMessage.header)
  return _internal_header();
}
inline void FeedMessage::unsafe_arena_set_allocated_header(
    ::transit_realtime::FeedHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.FeedMessage.header)
}
inline ::transit_realtime::FeedHeader* FeedMessage::release_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::transit_realtime::FeedHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::FeedHeader* FeedMessage::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:transit_realtime.FeedMessage.header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::transit_realtime::FeedHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::transit_realtime::FeedHeader* FeedMessage::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::FeedHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::transit_realtime::FeedHeader* FeedMessage::mutable_header() {
  ::transit_realtime::FeedHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedMessage.header)
  return _msg;
}
inline void FeedMessage::set_allocated_header(::transit_realtime::FeedHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedMessage.header)
}

// repeated .transit_realtime.FeedEntity entity = 2;
inline int FeedMessage::_internal_entity_size() const {
  return _impl_.entity_.size();
}
inline int FeedMessage::entity_size() const {
  return _internal_entity_size();
}
inline void FeedMessage::clear_entity() {
  _impl_.entity_.Clear();
}
inline ::transit_realtime::FeedEntity* FeedMessage::mutable_entity(int index) {
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedMessage.entity)
  return _impl_.entity_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::FeedEntity >*
FeedMessage::mutable_entity() {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.FeedMessage.entity)
  return &_impl_.entity_;
}
inline const ::transit_realtime::FeedEntity& FeedMessage::_internal_entity(int index) const {
  return _impl_.entity_.Get(index);
}
inline const ::transit_realtime::FeedEntity& FeedMessage::entity(int index) const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedMessage.entity)
  return _internal_entity(index);
}
inline ::transit_realtime::FeedEntity* FeedMessage::_internal_add_entity() {
  return _impl_.entity_.Add();
}
inline ::transit_realtime::FeedEntity* FeedMessage::add_entity() {
  ::transit_realtime::FeedEntity* _add = _internal_add_entity();
  // @@protoc_insertion_point(field_add:transit_realtime.FeedMessage.entity)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::FeedEntity >&
FeedMessage::entity() const {
  // @@protoc_insertion_point(field_list:transit_realtime.FeedMessage.entity)
  return _impl_.entity_;
}

// -------------------------------------------------------------------

// FeedHeader

// required string gtfs_realtime_version = 1;
inline bool FeedHeader::_internal_has_gtfs_realtime_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FeedHeader::has_gtfs_realtime_version() const {
  return _internal_has_gtfs_realtime_version();
}
inline void FeedHeader::clear_gtfs_realtime_version() {
  _impl_.gtfs_realtime_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FeedHeader::gtfs_realtime_version() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedHeader.gtfs_realtime_version)
  return _internal_gtfs_realtime_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeedHeader::set_gtfs_realtime_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.gtfs_realtime_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.FeedHeader.gtfs_realtime_version)
}
inline std::string* FeedHeader::mutable_gtfs_realtime_version() {
  std::string* _s = _internal_mutable_gtfs_realtime_version();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedHeader.gtfs_realtime_version)
  return _s;
}
inline const std::string& FeedHeader::_internal_gtfs_realtime_version() const {
  return _impl_.gtfs_realtime_version_.Get();
}
inline void FeedHeader::_internal_set_gtfs_realtime_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.gtfs_realtime_version_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedHeader::_internal_mutable_gtfs_realtime_version() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.gtfs_realtime_version_.Mutable(GetArenaForAllocation());
}
inline std::string* FeedHeader::release_gtfs_realtime_version() {
  // @@protoc_insertion_point(field_release:transit_realtime.FeedHeader.gtfs_realtime_version)
  if (!_internal_has_gtfs_realtime_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.gtfs_realtime_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gtfs_realtime_version_.IsDefault()) {
    _impl_.gtfs_realtime_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FeedHeader::set_allocated_gtfs_realtime_version(std::string* gtfs_realtime_version) {
  if (gtfs_realtime_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.gtfs_realtime_version_.SetAllocated(gtfs_realtime_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gtfs_realtime_version_.IsDefault()) {
    _impl_.gtfs_realtime_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedHeader.gtfs_realtime_version)
}

// optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];
inline bool FeedHeader::_internal_has_incrementality() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FeedHeader::has_incrementality() const {
  return _internal_has_incrementality();
}
inline void FeedHeader::clear_incrementality() {
  _impl_.incrementality_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::transit_realtime::FeedHeader_Incrementality FeedHeader::_internal_incrementality() const {
  return static_cast< ::transit_realtime::FeedHeader_Incrementality >(_impl_.incrementality_);
}
inline ::transit_realtime::FeedHeader_Incrementality FeedHeader::incrementality() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedHeader.incrementality)
  return _internal_incrementality();
}
inline void FeedHeader::_internal_set_incrementality(::transit_realtime::FeedHeader_Incrementality value) {
  assert(::transit_realtime::FeedHeader_Incrementality_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.incrementality_ = value;
}
inline void FeedHeader::set_incrementality(::transit_realtime::FeedHeader_Incrementality value) {
  _internal_set_incrementality(value);
  // @@protoc_insertion_point(field_set:transit_realtime.FeedHeader.incrementality)
}

// optional uint64 timestamp = 3;
inline bool FeedHeader::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FeedHeader::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void FeedHeader::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t FeedHeader::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t FeedHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedHeader.timestamp)
  return _internal_timestamp();
}
inline void FeedHeader::_internal_set_timestamp(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timestamp_ = value;
}
inline void FeedHeader::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:transit_realtime.FeedHeader.timestamp)
}

// -------------------------------------------------------------------

// FeedEntity

// required string id = 1;
inline bool FeedEntity::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FeedEntity::has_id() const {
  return _internal_has_id();
}
inline void FeedEntity::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FeedEntity::id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeedEntity::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.FeedEntity.id)
}
inline std::string* FeedEntity::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedEntity.id)
  return _s;
}
inline const std::string& FeedEntity::_internal_id() const {
  return _impl_.id_.Get();
}
inline void FeedEntity::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* FeedEntity::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* FeedEntity::release_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.FeedEntity.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FeedEntity::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedEntity.id)
}

// optional bool is_deleted = 2 [default = false];
inline bool FeedEntity::_internal_has_is_deleted() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool FeedEntity::has_is_deleted() const {
  return _internal_has_is_deleted();
}
inline void FeedEntity::clear_is_deleted() {
  _impl_.is_deleted_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool FeedEntity::_internal_is_deleted() const {
  return _impl_.is_deleted_;
}
inline bool FeedEntity::is_deleted() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.is_deleted)
  return _internal_is_deleted();
}
inline void FeedEntity::_internal_set_is_deleted(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.is_deleted_ = value;
}
inline void FeedEntity::set_is_deleted(bool value) {
  _internal_set_is_deleted(value);
  // @@protoc_insertion_point(field_set:transit_realtime.FeedEntity.is_deleted)
}

// optional .transit_realtime.TripUpdate trip_update = 3;
inline bool FeedEntity::_internal_has_trip_update() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trip_update_ != nullptr);
  return value;
}
inline bool FeedEntity::has_trip_update() const {
  return _internal_has_trip_update();
}
inline void FeedEntity::clear_trip_update() {
  if (_impl_.trip_update_ != nullptr) _impl_.trip_update_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::transit_realtime::TripUpdate& FeedEntity::_internal_trip_update() const {
  const ::transit_realtime::TripUpdate* p = _impl_.trip_update_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripUpdate&>(
      ::transit_realtime::_TripUpdate_default_instance_);
}
inline const ::transit_realtime::TripUpdate& FeedEntity::trip_update() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.trip_update)
  return _internal_trip_update();
}
inline void FeedEntity::unsafe_arena_set_allocated_trip_update(
    ::transit_realtime::TripUpdate* trip_update) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trip_update_);
  }
  _impl_.trip_update_ = trip_update;
  if (trip_update) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.FeedEntity.trip_update)
}
inline ::transit_realtime::TripUpdate* FeedEntity::release_trip_update() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TripUpdate* temp = _impl_.trip_update_;
  _impl_.trip_update_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TripUpdate* FeedEntity::unsafe_arena_release_trip_update() {
  // @@protoc_insertion_point(field_release:transit_realtime.FeedEntity.trip_update)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TripUpdate* temp = _impl_.trip_update_;
  _impl_.trip_update_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripUpdate* FeedEntity::_internal_mutable_trip_update() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.trip_update_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TripUpdate>(GetArenaForAllocation());
    _impl_.trip_update_ = p;
  }
  return _impl_.trip_update_;
}
inline ::transit_realtime::TripUpdate* FeedEntity::mutable_trip_update() {
  ::transit_realtime::TripUpdate* _msg = _internal_mutable_trip_update();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedEntity.trip_update)
  return _msg;
}
inline void FeedEntity::set_allocated_trip_update(::transit_realtime::TripUpdate* trip_update) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trip_update_;
  }
  if (trip_update) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trip_update);
    if (message_arena != submessage_arena) {
      trip_update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trip_update, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.trip_update_ = trip_update;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedEntity.trip_update)
}

// optional .transit_realtime.VehiclePosition vehicle = 4;
inline bool FeedEntity::_internal_has_vehicle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vehicle_ != nullptr);
  return value;
}
inline bool FeedEntity::has_vehicle() const {
  return _internal_has_vehicle();
}
inline void FeedEntity::clear_vehicle() {
  if (_impl_.vehicle_ != nullptr) _impl_.vehicle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::transit_realtime::VehiclePosition& FeedEntity::_internal_vehicle() const {
  const ::transit_realtime::VehiclePosition* p = _impl_.vehicle_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::VehiclePosition&>(
      ::transit_realtime::_VehiclePosition_default_instance_);
}
inline const ::transit_realtime::VehiclePosition& FeedEntity::vehicle() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.vehicle)
  return _internal_vehicle();
}
inline void FeedEntity::unsafe_arena_set_allocated_vehicle(
    ::transit_realtime::VehiclePosition* vehicle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vehicle_);
  }
  _impl_.vehicle_ = vehicle;
  if (vehicle) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.FeedEntity.vehicle)
}
inline ::transit_realtime::VehiclePosition* FeedEntity::release_vehicle() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::VehiclePosition* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::VehiclePosition* FeedEntity::unsafe_arena_release_vehicle() {
  // @@protoc_insertion_point(field_release:transit_realtime.FeedEntity.vehicle)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::VehiclePosition* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
  return temp;
}
inline ::transit_realtime::VehiclePosition* FeedEntity::_internal_mutable_vehicle() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.vehicle_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::VehiclePosition>(GetArenaForAllocation());
    _impl_.vehicle_ = p;
  }
  return _impl_.vehicle_;
}
inline ::transit_realtime::VehiclePosition* FeedEntity::mutable_vehicle() {
  ::transit_realtime::VehiclePosition* _msg = _internal_mutable_vehicle();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedEntity.vehicle)
  return _msg;
}
inline void FeedEntity::set_allocated_vehicle(::transit_realtime::VehiclePosition* vehicle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vehicle_;
  }
  if (vehicle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vehicle);
    if (message_arena != submessage_arena) {
      vehicle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.vehicle_ = vehicle;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedEntity.vehicle)
}

// optional .transit_realtime.Alert alert = 5;
inline bool FeedEntity::_internal_has_alert() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.alert_ != nullptr);
  return value;
}
inline bool FeedEntity::has_alert() const {
  return _internal_has_alert();
}
inline void FeedEntity::clear_alert() {
  if (_impl_.alert_ != nullptr) _impl_.alert_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::transit_realtime::Alert& FeedEntity::_internal_alert() const {
  const ::transit_realtime::Alert* p = _impl_.alert_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::Alert&>(
      ::transit_realtime::_Alert_default_instance_);
}
inline const ::transit_realtime::Alert& FeedEntity::alert() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.alert)
  return _internal_alert();
}
inline void FeedEntity::unsafe_arena_set_allocated_alert(
    ::transit_realtime::Alert* alert) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.alert_);
  }
  _impl_.alert_ = alert;
  if (alert) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.FeedEntity.alert)
}
inline ::transit_realtime::Alert* FeedEntity::release_alert() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::Alert* temp = _impl_.alert_;
  _impl_.alert_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::Alert* FeedEntity::unsafe_arena_release_alert() {
  // @@protoc_insertion_point(field_release:transit_realtime.FeedEntity.alert)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::Alert* temp = _impl_.alert_;
  _impl_.alert_ = nullptr;
  return temp;
}
inline ::transit_realtime::Alert* FeedEntity::_internal_mutable_alert() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.alert_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::Alert>(GetArenaForAllocation());
    _impl_.alert_ = p;
  }
  return _impl_.alert_;
}
inline ::transit_realtime::Alert* FeedEntity::mutable_alert() {
  ::transit_realtime::Alert* _msg = _internal_mutable_alert();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedEntity.alert)
  return _msg;
}
inline void FeedEntity::set_allocated_alert(::transit_realtime::Alert* alert) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.alert_;
  }
  if (alert) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(alert);
    if (message_arena != submessage_arena) {
      alert = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alert, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.alert_ = alert;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedEntity.alert)
}

// optional .transit_realtime.Shape shape = 6;
inline bool FeedEntity::_internal_has_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shape_ != nullptr);
  return value;
}
inline bool FeedEntity::has_shape() const {
  return _internal_has_shape();
}
inline void FeedEntity::clear_shape() {
  if (_impl_.shape_ != nullptr) _impl_.shape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::transit_realtime::Shape& FeedEntity::_internal_shape() const {
  const ::transit_realtime::Shape* p = _impl_.shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::Shape&>(
      ::transit_realtime::_Shape_default_instance_);
}
inline const ::transit_realtime::Shape& FeedEntity::shape() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.shape)
  return _internal_shape();
}
inline void FeedEntity::unsafe_arena_set_allocated_shape(
    ::transit_realtime::Shape* shape) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shape_);
  }
  _impl_.shape_ = shape;
  if (shape) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.FeedEntity.shape)
}
inline ::transit_realtime::Shape* FeedEntity::release_shape() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::transit_realtime::Shape* temp = _impl_.shape_;
  _impl_.shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::Shape* FeedEntity::unsafe_arena_release_shape() {
  // @@protoc_insertion_point(field_release:transit_realtime.FeedEntity.shape)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::transit_realtime::Shape* temp = _impl_.shape_;
  _impl_.shape_ = nullptr;
  return temp;
}
inline ::transit_realtime::Shape* FeedEntity::_internal_mutable_shape() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.shape_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::Shape>(GetArenaForAllocation());
    _impl_.shape_ = p;
  }
  return _impl_.shape_;
}
inline ::transit_realtime::Shape* FeedEntity::mutable_shape() {
  ::transit_realtime::Shape* _msg = _internal_mutable_shape();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedEntity.shape)
  return _msg;
}
inline void FeedEntity::set_allocated_shape(::transit_realtime::Shape* shape) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.shape_;
  }
  if (shape) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(shape);
    if (message_arena != submessage_arena) {
      shape = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shape, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.shape_ = shape;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedEntity.shape)
}

// -------------------------------------------------------------------

// TripUpdate_StopTimeEvent

// optional int32 delay = 1;
inline bool TripUpdate_StopTimeEvent::_internal_has_delay() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TripUpdate_StopTimeEvent::has_delay() const {
  return _internal_has_delay();
}
inline void TripUpdate_StopTimeEvent::clear_delay() {
  _impl_.delay_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t TripUpdate_StopTimeEvent::_internal_delay() const {
  return _impl_.delay_;
}
inline int32_t TripUpdate_StopTimeEvent::delay() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeEvent.delay)
  return _internal_delay();
}
inline void TripUpdate_StopTimeEvent::_internal_set_delay(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.delay_ = value;
}
inline void TripUpdate_StopTimeEvent::set_delay(int32_t value) {
  _internal_set_delay(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeEvent.delay)
}

// optional int64 time = 2;
inline bool TripUpdate_StopTimeEvent::_internal_has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TripUpdate_StopTimeEvent::has_time() const {
  return _internal_has_time();
}
inline void TripUpdate_StopTimeEvent::clear_time() {
  _impl_.time_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t TripUpdate_StopTimeEvent::_internal_time() const {
  return _impl_.time_;
}
inline int64_t TripUpdate_StopTimeEvent::time() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeEvent.time)
  return _internal_time();
}
inline void TripUpdate_StopTimeEvent::_internal_set_time(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.time_ = value;
}
inline void TripUpdate_StopTimeEvent::set_time(int64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeEvent.time)
}

// optional int32 uncertainty = 3;
inline bool TripUpdate_StopTimeEvent::_internal_has_uncertainty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TripUpdate_StopTimeEvent::has_uncertainty() const {
  return _internal_has_uncertainty();
}
inline void TripUpdate_StopTimeEvent::clear_uncertainty() {
  _impl_.uncertainty_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t TripUpdate_StopTimeEvent::_internal_uncertainty() const {
  return _impl_.uncertainty_;
}
inline int32_t TripUpdate_StopTimeEvent::uncertainty() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeEvent.uncertainty)
  return _internal_uncertainty();
}
inline void TripUpdate_StopTimeEvent::_internal_set_uncertainty(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.uncertainty_ = value;
}
inline void TripUpdate_StopTimeEvent::set_uncertainty(int32_t value) {
  _internal_set_uncertainty(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeEvent.uncertainty)
}

// -------------------------------------------------------------------

// TripUpdate_StopTimeUpdate_StopTimeProperties

// optional string assigned_stop_id = 1;
inline bool TripUpdate_StopTimeUpdate_StopTimeProperties::_internal_has_assigned_stop_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TripUpdate_StopTimeUpdate_StopTimeProperties::has_assigned_stop_id() const {
  return _internal_has_assigned_stop_id();
}
inline void TripUpdate_StopTimeUpdate_StopTimeProperties::clear_assigned_stop_id() {
  _impl_.assigned_stop_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TripUpdate_StopTimeUpdate_StopTimeProperties::assigned_stop_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.assigned_stop_id)
  return _internal_assigned_stop_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripUpdate_StopTimeUpdate_StopTimeProperties::set_assigned_stop_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.assigned_stop_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.assigned_stop_id)
}
inline std::string* TripUpdate_StopTimeUpdate_StopTimeProperties::mutable_assigned_stop_id() {
  std::string* _s = _internal_mutable_assigned_stop_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.assigned_stop_id)
  return _s;
}
inline const std::string& TripUpdate_StopTimeUpdate_StopTimeProperties::_internal_assigned_stop_id() const {
  return _impl_.assigned_stop_id_.Get();
}
inline void TripUpdate_StopTimeUpdate_StopTimeProperties::_internal_set_assigned_stop_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.assigned_stop_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TripUpdate_StopTimeUpdate_StopTimeProperties::_internal_mutable_assigned_stop_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.assigned_stop_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TripUpdate_StopTimeUpdate_StopTimeProperties::release_assigned_stop_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.assigned_stop_id)
  if (!_internal_has_assigned_stop_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.assigned_stop_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.assigned_stop_id_.IsDefault()) {
    _impl_.assigned_stop_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TripUpdate_StopTimeUpdate_StopTimeProperties::set_allocated_assigned_stop_id(std::string* assigned_stop_id) {
  if (assigned_stop_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.assigned_stop_id_.SetAllocated(assigned_stop_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.assigned_stop_id_.IsDefault()) {
    _impl_.assigned_stop_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.assigned_stop_id)
}

// -------------------------------------------------------------------

// TripUpdate_StopTimeUpdate

// optional uint32 stop_sequence = 1;
inline bool TripUpdate_StopTimeUpdate::_internal_has_stop_sequence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TripUpdate_StopTimeUpdate::has_stop_sequence() const {
  return _internal_has_stop_sequence();
}
inline void TripUpdate_StopTimeUpdate::clear_stop_sequence() {
  _impl_.stop_sequence_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t TripUpdate_StopTimeUpdate::_internal_stop_sequence() const {
  return _impl_.stop_sequence_;
}
inline uint32_t TripUpdate_StopTimeUpdate::stop_sequence() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.stop_sequence)
  return _internal_stop_sequence();
}
inline void TripUpdate_StopTimeUpdate::_internal_set_stop_sequence(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.stop_sequence_ = value;
}
inline void TripUpdate_StopTimeUpdate::set_stop_sequence(uint32_t value) {
  _internal_set_stop_sequence(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeUpdate.stop_sequence)
}

// optional string stop_id = 4;
inline bool TripUpdate_StopTimeUpdate::_internal_has_stop_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TripUpdate_StopTimeUpdate::has_stop_id() const {
  return _internal_has_stop_id();
}
inline void TripUpdate_StopTimeUpdate::clear_stop_id() {
  _impl_.stop_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TripUpdate_StopTimeUpdate::stop_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
  return _internal_stop_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripUpdate_StopTimeUpdate::set_stop_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stop_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
}
inline std::string* TripUpdate_StopTimeUpdate::mutable_stop_id() {
  std::string* _s = _internal_mutable_stop_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
  return _s;
}
inline const std::string& TripUpdate_StopTimeUpdate::_internal_stop_id() const {
  return _impl_.stop_id_.Get();
}
inline void TripUpdate_StopTimeUpdate::_internal_set_stop_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stop_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TripUpdate_StopTimeUpdate::_internal_mutable_stop_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stop_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TripUpdate_StopTimeUpdate::release_stop_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
  if (!_internal_has_stop_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stop_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stop_id_.IsDefault()) {
    _impl_.stop_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TripUpdate_StopTimeUpdate::set_allocated_stop_id(std::string* stop_id) {
  if (stop_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stop_id_.SetAllocated(stop_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stop_id_.IsDefault()) {
    _impl_.stop_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
}

// optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;
inline bool TripUpdate_StopTimeUpdate::_internal_has_arrival() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.arrival_ != nullptr);
  return value;
}
inline bool TripUpdate_StopTimeUpdate::has_arrival() const {
  return _internal_has_arrival();
}
inline void TripUpdate_StopTimeUpdate::clear_arrival() {
  if (_impl_.arrival_ != nullptr) _impl_.arrival_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::transit_realtime::TripUpdate_StopTimeEvent& TripUpdate_StopTimeUpdate::_internal_arrival() const {
  const ::transit_realtime::TripUpdate_StopTimeEvent* p = _impl_.arrival_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripUpdate_StopTimeEvent&>(
      ::transit_realtime::_TripUpdate_StopTimeEvent_default_instance_);
}
inline const ::transit_realtime::TripUpdate_StopTimeEvent& TripUpdate_StopTimeUpdate::arrival() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.arrival)
  return _internal_arrival();
}
inline void TripUpdate_StopTimeUpdate::unsafe_arena_set_allocated_arrival(
    ::transit_realtime::TripUpdate_StopTimeEvent* arrival) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.arrival_);
  }
  _impl_.arrival_ = arrival;
  if (arrival) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.arrival)
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::release_arrival() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TripUpdate_StopTimeEvent* temp = _impl_.arrival_;
  _impl_.arrival_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::unsafe_arena_release_arrival() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.StopTimeUpdate.arrival)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TripUpdate_StopTimeEvent* temp = _impl_.arrival_;
  _impl_.arrival_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::_internal_mutable_arrival() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.arrival_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TripUpdate_StopTimeEvent>(GetArenaForAllocation());
    _impl_.arrival_ = p;
  }
  return _impl_.arrival_;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::mutable_arrival() {
  ::transit_realtime::TripUpdate_StopTimeEvent* _msg = _internal_mutable_arrival();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.StopTimeUpdate.arrival)
  return _msg;
}
inline void TripUpdate_StopTimeUpdate::set_allocated_arrival(::transit_realtime::TripUpdate_StopTimeEvent* arrival) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.arrival_;
  }
  if (arrival) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(arrival);
    if (message_arena != submessage_arena) {
      arrival = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arrival, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.arrival_ = arrival;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.arrival)
}

// optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;
inline bool TripUpdate_StopTimeUpdate::_internal_has_departure() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.departure_ != nullptr);
  return value;
}
inline bool TripUpdate_StopTimeUpdate::has_departure() const {
  return _internal_has_departure();
}
inline void TripUpdate_StopTimeUpdate::clear_departure() {
  if (_impl_.departure_ != nullptr) _impl_.departure_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::transit_realtime::TripUpdate_StopTimeEvent& TripUpdate_StopTimeUpdate::_internal_departure() const {
  const ::transit_realtime::TripUpdate_StopTimeEvent* p = _impl_.departure_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripUpdate_StopTimeEvent&>(
      ::transit_realtime::_TripUpdate_StopTimeEvent_default_instance_);
}
inline const ::transit_realtime::TripUpdate_StopTimeEvent& TripUpdate_StopTimeUpdate::departure() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.departure)
  return _internal_departure();
}
inline void TripUpdate_StopTimeUpdate::unsafe_arena_set_allocated_departure(
    ::transit_realtime::TripUpdate_StopTimeEvent* departure) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.departure_);
  }
  _impl_.departure_ = departure;
  if (departure) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.departure)
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::release_departure() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::TripUpdate_StopTimeEvent* temp = _impl_.departure_;
  _impl_.departure_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::unsafe_arena_release_departure() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.StopTimeUpdate.departure)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::TripUpdate_StopTimeEvent* temp = _impl_.departure_;
  _impl_.departure_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::_internal_mutable_departure() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.departure_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TripUpdate_StopTimeEvent>(GetArenaForAllocation());
    _impl_.departure_ = p;
  }
  return _impl_.departure_;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::mutable_departure() {
  ::transit_realtime::TripUpdate_StopTimeEvent* _msg = _internal_mutable_departure();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.StopTimeUpdate.departure)
  return _msg;
}
inline void TripUpdate_StopTimeUpdate::set_allocated_departure(::transit_realtime::TripUpdate_StopTimeEvent* departure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.departure_;
  }
  if (departure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(departure);
    if (message_arena != submessage_arena) {
      departure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, departure, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.departure_ = departure;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.departure)
}

// optional .transit_realtime.VehiclePosition.OccupancyStatus departure_occupancy_status = 7;
inline bool TripUpdate_StopTimeUpdate::_internal_has_departure_occupancy_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TripUpdate_StopTimeUpdate::has_departure_occupancy_status() const {
  return _internal_has_departure_occupancy_status();
}
inline void TripUpdate_StopTimeUpdate::clear_departure_occupancy_status() {
  _impl_.departure_occupancy_status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::transit_realtime::VehiclePosition_OccupancyStatus TripUpdate_StopTimeUpdate::_internal_departure_occupancy_status() const {
  return static_cast< ::transit_realtime::VehiclePosition_OccupancyStatus >(_impl_.departure_occupancy_status_);
}
inline ::transit_realtime::VehiclePosition_OccupancyStatus TripUpdate_StopTimeUpdate::departure_occupancy_status() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.departure_occupancy_status)
  return _internal_departure_occupancy_status();
}
inline void TripUpdate_StopTimeUpdate::_internal_set_departure_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value) {
  assert(::transit_realtime::VehiclePosition_OccupancyStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.departure_occupancy_status_ = value;
}
inline void TripUpdate_StopTimeUpdate::set_departure_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value) {
  _internal_set_departure_occupancy_status(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeUpdate.departure_occupancy_status)
}

// optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];
inline bool TripUpdate_StopTimeUpdate::_internal_has_schedule_relationship() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TripUpdate_StopTimeUpdate::has_schedule_relationship() const {
  return _internal_has_schedule_relationship();
}
inline void TripUpdate_StopTimeUpdate::clear_schedule_relationship() {
  _impl_.schedule_relationship_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate::_internal_schedule_relationship() const {
  return static_cast< ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship >(_impl_.schedule_relationship_);
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate::schedule_relationship() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.schedule_relationship)
  return _internal_schedule_relationship();
}
inline void TripUpdate_StopTimeUpdate::_internal_set_schedule_relationship(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship value) {
  assert(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.schedule_relationship_ = value;
}
inline void TripUpdate_StopTimeUpdate::set_schedule_relationship(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship value) {
  _internal_set_schedule_relationship(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeUpdate.schedule_relationship)
}

// optional .transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;
inline bool TripUpdate_StopTimeUpdate::_internal_has_stop_time_properties() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stop_time_properties_ != nullptr);
  return value;
}
inline bool TripUpdate_StopTimeUpdate::has_stop_time_properties() const {
  return _internal_has_stop_time_properties();
}
inline void TripUpdate_StopTimeUpdate::clear_stop_time_properties() {
  if (_impl_.stop_time_properties_ != nullptr) _impl_.stop_time_properties_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties& TripUpdate_StopTimeUpdate::_internal_stop_time_properties() const {
  const ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* p = _impl_.stop_time_properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties&>(
      ::transit_realtime::_TripUpdate_StopTimeUpdate_StopTimeProperties_default_instance_);
}
inline const ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties& TripUpdate_StopTimeUpdate::stop_time_properties() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.stop_time_properties)
  return _internal_stop_time_properties();
}
inline void TripUpdate_StopTimeUpdate::unsafe_arena_set_allocated_stop_time_properties(
    ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* stop_time_properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stop_time_properties_);
  }
  _impl_.stop_time_properties_ = stop_time_properties;
  if (stop_time_properties) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.stop_time_properties)
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* TripUpdate_StopTimeUpdate::release_stop_time_properties() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* temp = _impl_.stop_time_properties_;
  _impl_.stop_time_properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* TripUpdate_StopTimeUpdate::unsafe_arena_release_stop_time_properties() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.StopTimeUpdate.stop_time_properties)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* temp = _impl_.stop_time_properties_;
  _impl_.stop_time_properties_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* TripUpdate_StopTimeUpdate::_internal_mutable_stop_time_properties() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.stop_time_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties>(GetArenaForAllocation());
    _impl_.stop_time_properties_ = p;
  }
  return _impl_.stop_time_properties_;
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* TripUpdate_StopTimeUpdate::mutable_stop_time_properties() {
  ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* _msg = _internal_mutable_stop_time_properties();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.StopTimeUpdate.stop_time_properties)
  return _msg;
}
inline void TripUpdate_StopTimeUpdate::set_allocated_stop_time_properties(::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* stop_time_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stop_time_properties_;
  }
  if (stop_time_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stop_time_properties);
    if (message_arena != submessage_arena) {
      stop_time_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stop_time_properties, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.stop_time_properties_ = stop_time_properties;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.stop_time_properties)
}

// -------------------------------------------------------------------

// TripUpdate_TripProperties

// optional string trip_id = 1;
inline bool TripUpdate_TripProperties::_internal_has_trip_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TripUpdate_TripProperties::has_trip_id() const {
  return _internal_has_trip_id();
}
inline void TripUpdate_TripProperties::clear_trip_id() {
  _impl_.trip_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TripUpdate_TripProperties::trip_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.TripProperties.trip_id)
  return _internal_trip_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripUpdate_TripProperties::set_trip_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.trip_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.TripProperties.trip_id)
}
inline std::string* TripUpdate_TripProperties::mutable_trip_id() {
  std::string* _s = _internal_mutable_trip_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.TripProperties.trip_id)
  return _s;
}
inline const std::string& TripUpdate_TripProperties::_internal_trip_id() const {
  return _impl_.trip_id_.Get();
}
inline void TripUpdate_TripProperties::_internal_set_trip_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.trip_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TripUpdate_TripProperties::_internal_mutable_trip_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.trip_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TripUpdate_TripProperties::release_trip_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.TripProperties.trip_id)
  if (!_internal_has_trip_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.trip_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trip_id_.IsDefault()) {
    _impl_.trip_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TripUpdate_TripProperties::set_allocated_trip_id(std::string* trip_id) {
  if (trip_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.trip_id_.SetAllocated(trip_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trip_id_.IsDefault()) {
    _impl_.trip_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.TripProperties.trip_id)
}

// optional string start_date = 2;
inline bool TripUpdate_TripProperties::_internal_has_start_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TripUpdate_TripProperties::has_start_date() const {
  return _internal_has_start_date();
}
inline void TripUpdate_TripProperties::clear_start_date() {
  _impl_.start_date_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TripUpdate_TripProperties::start_date() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.TripProperties.start_date)
  return _internal_start_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripUpdate_TripProperties::set_start_date(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.start_date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.TripProperties.start_date)
}
inline std::string* TripUpdate_TripProperties::mutable_start_date() {
  std::string* _s = _internal_mutable_start_date();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.TripProperties.start_date)
  return _s;
}
inline const std::string& TripUpdate_TripProperties::_internal_start_date() const {
  return _impl_.start_date_.Get();
}
inline void TripUpdate_TripProperties::_internal_set_start_date(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.start_date_.Set(value, GetArenaForAllocation());
}
inline std::string* TripUpdate_TripProperties::_internal_mutable_start_date() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.start_date_.Mutable(GetArenaForAllocation());
}
inline std::string* TripUpdate_TripProperties::release_start_date() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.TripProperties.start_date)
  if (!_internal_has_start_date()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.start_date_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.start_date_.IsDefault()) {
    _impl_.start_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TripUpdate_TripProperties::set_allocated_start_date(std::string* start_date) {
  if (start_date != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.start_date_.SetAllocated(start_date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.start_date_.IsDefault()) {
    _impl_.start_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.TripProperties.start_date)
}

// optional string start_time = 3;
inline bool TripUpdate_TripProperties::_internal_has_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TripUpdate_TripProperties::has_start_time() const {
  return _internal_has_start_time();
}
inline void TripUpdate_TripProperties::clear_start_time() {
  _impl_.start_time_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TripUpdate_TripProperties::start_time() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.TripProperties.start_time)
  return _internal_start_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripUpdate_TripProperties::set_start_time(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.start_time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.TripProperties.start_time)
}
inline std::string* TripUpdate_TripProperties::mutable_start_time() {
  std::string* _s = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.TripProperties.start_time)
  return _s;
}
inline const std::string& TripUpdate_TripProperties::_internal_start_time() const {
  return _impl_.start_time_.Get();
}
inline void TripUpdate_TripProperties::_internal_set_start_time(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.start_time_.Set(value, GetArenaForAllocation());
}
inline std::string* TripUpdate_TripProperties::_internal_mutable_start_time() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.start_time_.Mutable(GetArenaForAllocation());
}
inline std::string* TripUpdate_TripProperties::release_start_time() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.TripProperties.start_time)
  if (!_internal_has_start_time()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.start_time_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.start_time_.IsDefault()) {
    _impl_.start_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TripUpdate_TripProperties::set_allocated_start_time(std::string* start_time) {
  if (start_time != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.start_time_.SetAllocated(start_time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.start_time_.IsDefault()) {
    _impl_.start_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.TripProperties.start_time)
}

// optional string shape_id = 4;
inline bool TripUpdate_TripProperties::_internal_has_shape_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TripUpdate_TripProperties::has_shape_id() const {
  return _internal_has_shape_id();
}
inline void TripUpdate_TripProperties::clear_shape_id() {
  _impl_.shape_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TripUpdate_TripProperties::shape_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.TripProperties.shape_id)
  return _internal_shape_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripUpdate_TripProperties::set_shape_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.shape_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.TripProperties.shape_id)
}
inline std::string* TripUpdate_TripProperties::mutable_shape_id() {
  std::string* _s = _internal_mutable_shape_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.TripProperties.shape_id)
  return _s;
}
inline const std::string& TripUpdate_TripProperties::_internal_shape_id() const {
  return _impl_.shape_id_.Get();
}
inline void TripUpdate_TripProperties::_internal_set_shape_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.shape_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TripUpdate_TripProperties::_internal_mutable_shape_id() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.shape_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TripUpdate_TripProperties::release_shape_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.TripProperties.shape_id)
  if (!_internal_has_shape_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.shape_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.shape_id_.IsDefault()) {
    _impl_.shape_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TripUpdate_TripProperties::set_allocated_shape_id(std::string* shape_id) {
  if (shape_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.shape_id_.SetAllocated(shape_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.shape_id_.IsDefault()) {
    _impl_.shape_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.TripProperties.shape_id)
}

// -------------------------------------------------------------------

// TripUpdate

// required .transit_realtime.TripDescriptor trip = 1;
inline bool TripUpdate::_internal_has_trip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trip_ != nullptr);
  return value;
}
inline bool TripUpdate::has_trip() const {
  return _internal_has_trip();
}
inline void TripUpdate::clear_trip() {
  if (_impl_.trip_ != nullptr) _impl_.trip_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::transit_realtime::TripDescriptor& TripUpdate::_internal_trip() const {
  const ::transit_realtime::TripDescriptor* p = _impl_.trip_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripDescriptor&>(
      ::transit_realtime::_TripDescriptor_default_instance_);
}
inline const ::transit_realtime::TripDescriptor& TripUpdate::trip() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.trip)
  return _internal_trip();
}
inline void TripUpdate::unsafe_arena_set_allocated_trip(
    ::transit_realtime::TripDescriptor* trip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trip_);
  }
  _impl_.trip_ = trip;
  if (trip) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.TripUpdate.trip)
}
inline ::transit_realtime::TripDescriptor* TripUpdate::release_trip() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::transit_realtime::TripDescriptor* temp = _impl_.trip_;
  _impl_.trip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TripDescriptor* TripUpdate::unsafe_arena_release_trip() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.trip)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::transit_realtime::TripDescriptor* temp = _impl_.trip_;
  _impl_.trip_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripDescriptor* TripUpdate::_internal_mutable_trip() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.trip_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TripDescriptor>(GetArenaForAllocation());
    _impl_.trip_ = p;
  }
  return _impl_.trip_;
}
inline ::transit_realtime::TripDescriptor* TripUpdate::mutable_trip() {
  ::transit_realtime::TripDescriptor* _msg = _internal_mutable_trip();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.trip)
  return _msg;
}
inline void TripUpdate::set_allocated_trip(::transit_realtime::TripDescriptor* trip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trip_;
  }
  if (trip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trip);
    if (message_arena != submessage_arena) {
      trip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trip, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.trip_ = trip;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.trip)
}

// optional .transit_realtime.VehicleDescriptor vehicle = 3;
inline bool TripUpdate::_internal_has_vehicle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vehicle_ != nullptr);
  return value;
}
inline bool TripUpdate::has_vehicle() const {
  return _internal_has_vehicle();
}
inline void TripUpdate::clear_vehicle() {
  if (_impl_.vehicle_ != nullptr) _impl_.vehicle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::transit_realtime::VehicleDescriptor& TripUpdate::_internal_vehicle() const {
  const ::transit_realtime::VehicleDescriptor* p = _impl_.vehicle_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::VehicleDescriptor&>(
      ::transit_realtime::_VehicleDescriptor_default_instance_);
}
inline const ::transit_realtime::VehicleDescriptor& TripUpdate::vehicle() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.vehicle)
  return _internal_vehicle();
}
inline void TripUpdate::unsafe_arena_set_allocated_vehicle(
    ::transit_realtime::VehicleDescriptor* vehicle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vehicle_);
  }
  _impl_.vehicle_ = vehicle;
  if (vehicle) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.TripUpdate.vehicle)
}
inline ::transit_realtime::VehicleDescriptor* TripUpdate::release_vehicle() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::VehicleDescriptor* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::VehicleDescriptor* TripUpdate::unsafe_arena_release_vehicle() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.vehicle)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::VehicleDescriptor* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
  return temp;
}
inline ::transit_realtime::VehicleDescriptor* TripUpdate::_internal_mutable_vehicle() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.vehicle_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::VehicleDescriptor>(GetArenaForAllocation());
    _impl_.vehicle_ = p;
  }
  return _impl_.vehicle_;
}
inline ::transit_realtime::VehicleDescriptor* TripUpdate::mutable_vehicle() {
  ::transit_realtime::VehicleDescriptor* _msg = _internal_mutable_vehicle();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.vehicle)
  return _msg;
}
inline void TripUpdate::set_allocated_vehicle(::transit_realtime::VehicleDescriptor* vehicle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vehicle_;
  }
  if (vehicle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vehicle);
    if (message_arena != submessage_arena) {
      vehicle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.vehicle_ = vehicle;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.vehicle)
}

// repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;
inline int TripUpdate::_internal_stop_time_update_size() const {
  return _impl_.stop_time_update_.size();
}
inline int TripUpdate::stop_time_update_size() const {
  return _internal_stop_time_update_size();
}
inline void TripUpdate::clear_stop_time_update() {
  _impl_.stop_time_update_.Clear();
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate* TripUpdate::mutable_stop_time_update(int index) {
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.stop_time_update)
  return _impl_.stop_time_update_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate >*
TripUpdate::mutable_stop_time_update() {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.TripUpdate.stop_time_update)
  return &_impl_.stop_time_update_;
}
inline const ::transit_realtime::TripUpdate_StopTimeUpdate& TripUpdate::_internal_stop_time_update(int index) const {
  return _impl_.stop_time_update_.Get(index);
}
inline const ::transit_realtime::TripUpdate_StopTimeUpdate& TripUpdate::stop_time_update(int index) const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.stop_time_update)
  return _internal_stop_time_update(index);
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate* TripUpdate::_internal_add_stop_time_update() {
  return _impl_.stop_time_update_.Add();
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate* TripUpdate::add_stop_time_update() {
  ::transit_realtime::TripUpdate_StopTimeUpdate* _add = _internal_add_stop_time_update();
  // @@protoc_insertion_point(field_add:transit_realtime.TripUpdate.stop_time_update)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate >&
TripUpdate::stop_time_update() const {
  // @@protoc_insertion_point(field_list:transit_realtime.TripUpdate.stop_time_update)
  return _impl_.stop_time_update_;
}

// optional uint64 timestamp = 4;
inline bool TripUpdate::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TripUpdate::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void TripUpdate::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t TripUpdate::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t TripUpdate::timestamp() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.timestamp)
  return _internal_timestamp();
}
inline void TripUpdate::_internal_set_timestamp(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.timestamp_ = value;
}
inline void TripUpdate::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.timestamp)
}

// optional int32 delay = 5;
inline bool TripUpdate::_internal_has_delay() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TripUpdate::has_delay() const {
  return _internal_has_delay();
}
inline void TripUpdate::clear_delay() {
  _impl_.delay_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t TripUpdate::_internal_delay() const {
  return _impl_.delay_;
}
inline int32_t TripUpdate::delay() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.delay)
  return _internal_delay();
}
inline void TripUpdate::_internal_set_delay(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.delay_ = value;
}
inline void TripUpdate::set_delay(int32_t value) {
  _internal_set_delay(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.delay)
}

// optional .transit_realtime.TripUpdate.TripProperties trip_properties = 6;
inline bool TripUpdate::_internal_has_trip_properties() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trip_properties_ != nullptr);
  return value;
}
inline bool TripUpdate::has_trip_properties() const {
  return _internal_has_trip_properties();
}
inline void TripUpdate::clear_trip_properties() {
  if (_impl_.trip_properties_ != nullptr) _impl_.trip_properties_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::transit_realtime::TripUpdate_TripProperties& TripUpdate::_internal_trip_properties() const {
  const ::transit_realtime::TripUpdate_TripProperties* p = _impl_.trip_properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripUpdate_TripProperties&>(
      ::transit_realtime::_TripUpdate_TripProperties_default_instance_);
}
inline const ::transit_realtime::TripUpdate_TripProperties& TripUpdate::trip_properties() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.trip_properties)
  return _internal_trip_properties();
}
inline void TripUpdate::unsafe_arena_set_allocated_trip_properties(
    ::transit_realtime::TripUpdate_TripProperties* trip_properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trip_properties_);
  }
  _impl_.trip_properties_ = trip_properties;
  if (trip_properties) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.TripUpdate.trip_properties)
}
inline ::transit_realtime::TripUpdate_TripProperties* TripUpdate::release_trip_properties() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::TripUpdate_TripProperties* temp = _impl_.trip_properties_;
  _impl_.trip_properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TripUpdate_TripProperties* TripUpdate::unsafe_arena_release_trip_properties() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.trip_properties)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::TripUpdate_TripProperties* temp = _impl_.trip_properties_;
  _impl_.trip_properties_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripUpdate_TripProperties* TripUpdate::_internal_mutable_trip_properties() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.trip_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TripUpdate_TripProperties>(GetArenaForAllocation());
    _impl_.trip_properties_ = p;
  }
  return _impl_.trip_properties_;
}
inline ::transit_realtime::TripUpdate_TripProperties* TripUpdate::mutable_trip_properties() {
  ::transit_realtime::TripUpdate_TripProperties* _msg = _internal_mutable_trip_properties();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.trip_properties)
  return _msg;
}
inline void TripUpdate::set_allocated_trip_properties(::transit_realtime::TripUpdate_TripProperties* trip_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trip_properties_;
  }
  if (trip_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trip_properties);
    if (message_arena != submessage_arena) {
      trip_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trip_properties, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.trip_properties_ = trip_properties;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.trip_properties)
}

// -------------------------------------------------------------------

// VehiclePosition_CarriageDetails

// optional string id = 1;
inline bool VehiclePosition_CarriageDetails::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VehiclePosition_CarriageDetails::has_id() const {
  return _internal_has_id();
}
inline void VehiclePosition_CarriageDetails::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VehiclePosition_CarriageDetails::id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.CarriageDetails.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VehiclePosition_CarriageDetails::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.CarriageDetails.id)
}
inline std::string* VehiclePosition_CarriageDetails::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.CarriageDetails.id)
  return _s;
}
inline const std::string& VehiclePosition_CarriageDetails::_internal_id() const {
  return _impl_.id_.Get();
}
inline void VehiclePosition_CarriageDetails::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* VehiclePosition_CarriageDetails::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* VehiclePosition_CarriageDetails::release_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehiclePosition.CarriageDetails.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VehiclePosition_CarriageDetails::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehiclePosition.CarriageDetails.id)
}

// optional string label = 2;
inline bool VehiclePosition_CarriageDetails::_internal_has_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VehiclePosition_CarriageDetails::has_label() const {
  return _internal_has_label();
}
inline void VehiclePosition_CarriageDetails::clear_label() {
  _impl_.label_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VehiclePosition_CarriageDetails::label() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.CarriageDetails.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VehiclePosition_CarriageDetails::set_label(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.CarriageDetails.label)
}
inline std::string* VehiclePosition_CarriageDetails::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.CarriageDetails.label)
  return _s;
}
inline const std::string& VehiclePosition_CarriageDetails::_internal_label() const {
  return _impl_.label_.Get();
}
inline void VehiclePosition_CarriageDetails::_internal_set_label(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* VehiclePosition_CarriageDetails::_internal_mutable_label() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.label_.Mutable(GetArenaForAllocation());
}
inline std::string* VehiclePosition_CarriageDetails::release_label() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehiclePosition.CarriageDetails.label)
  if (!_internal_has_label()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.label_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VehiclePosition_CarriageDetails::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehiclePosition.CarriageDetails.label)
}

// optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 3 [default = NO_DATA_AVAILABLE];
inline bool VehiclePosition_CarriageDetails::_internal_has_occupancy_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool VehiclePosition_CarriageDetails::has_occupancy_status() const {
  return _internal_has_occupancy_status();
}
inline void VehiclePosition_CarriageDetails::clear_occupancy_status() {
  _impl_.occupancy_status_ = 7;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::transit_realtime::VehiclePosition_OccupancyStatus VehiclePosition_CarriageDetails::_internal_occupancy_status() const {
  return static_cast< ::transit_realtime::VehiclePosition_OccupancyStatus >(_impl_.occupancy_status_);
}
inline ::transit_realtime::VehiclePosition_OccupancyStatus VehiclePosition_CarriageDetails::occupancy_status() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.CarriageDetails.occupancy_status)
  return _internal_occupancy_status();
}
inline void VehiclePosition_CarriageDetails::_internal_set_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value) {
  assert(::transit_realtime::VehiclePosition_OccupancyStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.occupancy_status_ = value;
}
inline void VehiclePosition_CarriageDetails::set_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value) {
  _internal_set_occupancy_status(value);
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.CarriageDetails.occupancy_status)
}

// optional int32 occupancy_percentage = 4 [default = -1];
inline bool VehiclePosition_CarriageDetails::_internal_has_occupancy_percentage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool VehiclePosition_CarriageDetails::has_occupancy_percentage() const {
  return _internal_has_occupancy_percentage();
}
inline void VehiclePosition_CarriageDetails::clear_occupancy_percentage() {
  _impl_.occupancy_percentage_ = -1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t VehiclePosition_CarriageDetails::_internal_occupancy_percentage() const {
  return _impl_.occupancy_percentage_;
}
inline int32_t VehiclePosition_CarriageDetails::occupancy_percentage() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.CarriageDetails.occupancy_percentage)
  return _internal_occupancy_percentage();
}
inline void VehiclePosition_CarriageDetails::_internal_set_occupancy_percentage(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.occupancy_percentage_ = value;
}
inline void VehiclePosition_CarriageDetails::set_occupancy_percentage(int32_t value) {
  _internal_set_occupancy_percentage(value);
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.CarriageDetails.occupancy_percentage)
}

// optional uint32 carriage_sequence = 5;
inline bool VehiclePosition_CarriageDetails::_internal_has_carriage_sequence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VehiclePosition_CarriageDetails::has_carriage_sequence() const {
  return _internal_has_carriage_sequence();
}
inline void VehiclePosition_CarriageDetails::clear_carriage_sequence() {
  _impl_.carriage_sequence_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t VehiclePosition_CarriageDetails::_internal_carriage_sequence() const {
  return _impl_.carriage_sequence_;
}
inline uint32_t VehiclePosition_CarriageDetails::carriage_sequence() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.CarriageDetails.carriage_sequence)
  return _internal_carriage_sequence();
}
inline void VehiclePosition_CarriageDetails::_internal_set_carriage_sequence(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.carriage_sequence_ = value;
}
inline void VehiclePosition_CarriageDetails::set_carriage_sequence(uint32_t value) {
  _internal_set_carriage_sequence(value);
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.CarriageDetails.carriage_sequence)
}

// -------------------------------------------------------------------

// VehiclePosition

// optional .transit_realtime.TripDescriptor trip = 1;
inline bool VehiclePosition::_internal_has_trip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trip_ != nullptr);
  return value;
}
inline bool VehiclePosition::has_trip() const {
  return _internal_has_trip();
}
inline void VehiclePosition::clear_trip() {
  if (_impl_.trip_ != nullptr) _impl_.trip_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::transit_realtime::TripDescriptor& VehiclePosition::_internal_trip() const {
  const ::transit_realtime::TripDescriptor* p = _impl_.trip_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripDescriptor&>(
      ::transit_realtime::_TripDescriptor_default_instance_);
}
inline const ::transit_realtime::TripDescriptor& VehiclePosition::trip() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.trip)
  return _internal_trip();
}
inline void VehiclePosition::unsafe_arena_set_allocated_trip(
    ::transit_realtime::TripDescriptor* trip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trip_);
  }
  _impl_.trip_ = trip;
  if (trip) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.VehiclePosition.trip)
}
inline ::transit_realtime::TripDescriptor* VehiclePosition::release_trip() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TripDescriptor* temp = _impl_.trip_;
  _impl_.trip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TripDescriptor* VehiclePosition::unsafe_arena_release_trip() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehiclePosition.trip)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TripDescriptor* temp = _impl_.trip_;
  _impl_.trip_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripDescriptor* VehiclePosition::_internal_mutable_trip() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.trip_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TripDescriptor>(GetArenaForAllocation());
    _impl_.trip_ = p;
  }
  return _impl_.trip_;
}
inline ::transit_realtime::TripDescriptor* VehiclePosition::mutable_trip() {
  ::transit_realtime::TripDescriptor* _msg = _internal_mutable_trip();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.trip)
  return _msg;
}
inline void VehiclePosition::set_allocated_trip(::transit_realtime::TripDescriptor* trip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trip_;
  }
  if (trip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trip);
    if (message_arena != submessage_arena) {
      trip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trip, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.trip_ = trip;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehiclePosition.trip)
}

// optional .transit_realtime.VehicleDescriptor vehicle = 8;
inline bool VehiclePosition::_internal_has_vehicle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vehicle_ != nullptr);
  return value;
}
inline bool VehiclePosition::has_vehicle() const {
  return _internal_has_vehicle();
}
inline void VehiclePosition::clear_vehicle() {
  if (_impl_.vehicle_ != nullptr) _impl_.vehicle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::transit_realtime::VehicleDescriptor& VehiclePosition::_internal_vehicle() const {
  const ::transit_realtime::VehicleDescriptor* p = _impl_.vehicle_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::VehicleDescriptor&>(
      ::transit_realtime::_VehicleDescriptor_default_instance_);
}
inline const ::transit_realtime::VehicleDescriptor& VehiclePosition::vehicle() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.vehicle)
  return _internal_vehicle();
}
inline void VehiclePosition::unsafe_arena_set_allocated_vehicle(
    ::transit_realtime::VehicleDescriptor* vehicle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vehicle_);
  }
  _impl_.vehicle_ = vehicle;
  if (vehicle) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.VehiclePosition.vehicle)
}
inline ::transit_realtime::VehicleDescriptor* VehiclePosition::release_vehicle() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::VehicleDescriptor* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::VehicleDescriptor* VehiclePosition::unsafe_arena_release_vehicle() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehiclePosition.vehicle)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::VehicleDescriptor* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
  return temp;
}
inline ::transit_realtime::VehicleDescriptor* VehiclePosition::_internal_mutable_vehicle() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.vehicle_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::VehicleDescriptor>(GetArenaForAllocation());
    _impl_.vehicle_ = p;
  }
  return _impl_.vehicle_;
}
inline ::transit_realtime::VehicleDescriptor* VehiclePosition::mutable_vehicle() {
  ::transit_realtime::VehicleDescriptor* _msg = _internal_mutable_vehicle();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.vehicle)
  return _msg;
}
inline void VehiclePosition::set_allocated_vehicle(::transit_realtime::VehicleDescriptor* vehicle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vehicle_;
  }
  if (vehicle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vehicle);
    if (message_arena != submessage_arena) {
      vehicle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.vehicle_ = vehicle;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehiclePosition.vehicle)
}

// optional .transit_realtime.Position position = 2;
inline bool VehiclePosition::_internal_has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline bool VehiclePosition::has_position() const {
  return _internal_has_position();
}
inline void VehiclePosition::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::transit_realtime::Position& VehiclePosition::_internal_position() const {
  const ::transit_realtime::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::Position&>(
      ::transit_realtime::_Position_default_instance_);
}
inline const ::transit_realtime::Position& VehiclePosition::position() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.position)
  return _internal_position();
}
inline void VehiclePosition::unsafe_arena_set_allocated_position(
    ::transit_realtime::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.VehiclePosition.position)
}
inline ::transit_realtime::Position* VehiclePosition::release_position() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::Position* VehiclePosition::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehiclePosition.position)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::transit_realtime::Position* VehiclePosition::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::Position>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::transit_realtime::Position* VehiclePosition::mutable_position() {
  ::transit_realtime::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.position)
  return _msg;
}
inline void VehiclePosition::set_allocated_position(::transit_realtime::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehiclePosition.position)
}

// optional uint32 current_stop_sequence = 3;
inline bool VehiclePosition::_internal_has_current_stop_sequence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool VehiclePosition::has_current_stop_sequence() const {
  return _internal_has_current_stop_sequence();
}
inline void VehiclePosition::clear_current_stop_sequence() {
  _impl_.current_stop_sequence_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t VehiclePosition::_internal_current_stop_sequence() const {
  return _impl_.current_stop_sequence_;
}
inline uint32_t VehiclePosition::current_stop_sequence() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.current_stop_sequence)
  return _internal_current_stop_sequence();
}
inline void VehiclePosition::_internal_set_current_stop_sequence(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.current_stop_sequence_ = value;
}
inline void VehiclePosition::set_current_stop_sequence(uint32_t value) {
  _internal_set_current_stop_sequence(value);
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.current_stop_sequence)
}

// optional string stop_id = 7;
inline bool VehiclePosition::_internal_has_stop_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VehiclePosition::has_stop_id() const {
  return _internal_has_stop_id();
}
inline void VehiclePosition::clear_stop_id() {
  _impl_.stop_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VehiclePosition::stop_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.stop_id)
  return _internal_stop_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VehiclePosition::set_stop_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stop_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.stop_id)
}
inline std::string* VehiclePosition::mutable_stop_id() {
  std::string* _s = _internal_mutable_stop_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.stop_id)
  return _s;
}
inline const std::string& VehiclePosition::_internal_stop_id() const {
  return _impl_.stop_id_.Get();
}
inline void VehiclePosition::_internal_set_stop_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stop_id_.Set(value, GetArenaForAllocation());
}
inline std::string* VehiclePosition::_internal_mutable_stop_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stop_id_.Mutable(GetArenaForAllocation());
}
inline std::string* VehiclePosition::release_stop_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehiclePosition.stop_id)
  if (!_internal_has_stop_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stop_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stop_id_.IsDefault()) {
    _impl_.stop_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VehiclePosition::set_allocated_stop_id(std::string* stop_id) {
  if (stop_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stop_id_.SetAllocated(stop_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stop_id_.IsDefault()) {
    _impl_.stop_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehiclePosition.stop_id)
}

// optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];
inline bool VehiclePosition::_internal_has_current_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool VehiclePosition::has_current_status() const {
  return _internal_has_current_status();
}
inline void VehiclePosition::clear_current_status() {
  _impl_.current_status_ = 2;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::transit_realtime::VehiclePosition_VehicleStopStatus VehiclePosition::_internal_current_status() const {
  return static_cast< ::transit_realtime::VehiclePosition_VehicleStopStatus >(_impl_.current_status_);
}
inline ::transit_realtime::VehiclePosition_VehicleStopStatus VehiclePosition::current_status() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.current_status)
  return _internal_current_status();
}
inline void VehiclePosition::_internal_set_current_status(::transit_realtime::VehiclePosition_VehicleStopStatus value) {
  assert(::transit_realtime::VehiclePosition_VehicleStopStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.current_status_ = value;
}
inline void VehiclePosition::set_current_status(::transit_realtime::VehiclePosition_VehicleStopStatus value) {
  _internal_set_current_status(value);
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.current_status)
}

// optional uint64 timestamp = 5;
inline bool VehiclePosition::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool VehiclePosition::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void VehiclePosition::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint64_t VehiclePosition::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t VehiclePosition::timestamp() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.timestamp)
  return _internal_timestamp();
}
inline void VehiclePosition::_internal_set_timestamp(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.timestamp_ = value;
}
inline void VehiclePosition::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.timestamp)
}

// optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;
inline bool VehiclePosition::_internal_has_congestion_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool VehiclePosition::has_congestion_level() const {
  return _internal_has_congestion_level();
}
inline void VehiclePosition::clear_congestion_level() {
  _impl_.congestion_level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::transit_realtime::VehiclePosition_CongestionLevel VehiclePosition::_internal_congestion_level() const {
  return static_cast< ::transit_realtime::VehiclePosition_CongestionLevel >(_impl_.congestion_level_);
}
inline ::transit_realtime::VehiclePosition_CongestionLevel VehiclePosition::congestion_level() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.congestion_level)
  return _internal_congestion_level();
}
inline void VehiclePosition::_internal_set_congestion_level(::transit_realtime::VehiclePosition_CongestionLevel value) {
  assert(::transit_realtime::VehiclePosition_CongestionLevel_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.congestion_level_ = value;
}
inline void VehiclePosition::set_congestion_level(::transit_realtime::VehiclePosition_CongestionLevel value) {
  _internal_set_congestion_level(value);
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.congestion_level)
}

// optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;
inline bool VehiclePosition::_internal_has_occupancy_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool VehiclePosition::has_occupancy_status() const {
  return _internal_has_occupancy_status();
}
inline void VehiclePosition::clear_occupancy_status() {
  _impl_.occupancy_status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::transit_realtime::VehiclePosition_OccupancyStatus VehiclePosition::_internal_occupancy_status() const {
  return static_cast< ::transit_realtime::VehiclePosition_OccupancyStatus >(_impl_.occupancy_status_);
}
inline ::transit_realtime::VehiclePosition_OccupancyStatus VehiclePosition::occupancy_status() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.occupancy_status)
  return _internal_occupancy_status();
}
inline void VehiclePosition::_internal_set_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value) {
  assert(::transit_realtime::VehiclePosition_OccupancyStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.occupancy_status_ = value;
}
inline void VehiclePosition::set_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value) {
  _internal_set_occupancy_status(value);
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.occupancy_status)
}

// optional uint32 occupancy_percentage = 10;
inline bool VehiclePosition::_internal_has_occupancy_percentage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool VehiclePosition::has_occupancy_percentage() const {
  return _internal_has_occupancy_percentage();
}
inline void VehiclePosition::clear_occupancy_percentage() {
  _impl_.occupancy_percentage_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t VehiclePosition::_internal_occupancy_percentage() const {
  return _impl_.occupancy_percentage_;
}
inline uint32_t VehiclePosition::occupancy_percentage() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.occupancy_percentage)
  return _internal_occupancy_percentage();
}
inline void VehiclePosition::_internal_set_occupancy_percentage(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.occupancy_percentage_ = value;
}
inline void VehiclePosition::set_occupancy_percentage(uint32_t value) {
  _internal_set_occupancy_percentage(value);
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.occupancy_percentage)
}

// repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;
inline int VehiclePosition::_internal_multi_carriage_details_size() const {
  return _impl_.multi_carriage_details_.size();
}
inline int VehiclePosition::multi_carriage_details_size() const {
  return _internal_multi_carriage_details_size();
}
inline void VehiclePosition::clear_multi_carriage_details() {
  _impl_.multi_carriage_details_.Clear();
}
inline ::transit_realtime::VehiclePosition_CarriageDetails* VehiclePosition::mutable_multi_carriage_details(int index) {
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.multi_carriage_details)
  return _impl_.multi_carriage_details_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::VehiclePosition_CarriageDetails >*
VehiclePosition::mutable_multi_carriage_details() {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.VehiclePosition.multi_carriage_details)
  return &_impl_.multi_carriage_details_;
}
inline const ::transit_realtime::VehiclePosition_CarriageDetails& VehiclePosition::_internal_multi_carriage_details(int index) const {
  return _impl_.multi_carriage_details_.Get(index);
}
inline const ::transit_realtime::VehiclePosition_CarriageDetails& VehiclePosition::multi_carriage_details(int index) const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.multi_carriage_details)
  return _internal_multi_carriage_details(index);
}
inline ::transit_realtime::VehiclePosition_CarriageDetails* VehiclePosition::_internal_add_multi_carriage_details() {
  return _impl_.multi_carriage_details_.Add();
}
inline ::transit_realtime::VehiclePosition_CarriageDetails* VehiclePosition::add_multi_carriage_details() {
  ::transit_realtime::VehiclePosition_CarriageDetails* _add = _internal_add_multi_carriage_details();
  // @@protoc_insertion_point(field_add:transit_realtime.VehiclePosition.multi_carriage_details)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::VehiclePosition_CarriageDetails >&
VehiclePosition::multi_carriage_details() const {
  // @@protoc_insertion_point(field_list:transit_realtime.VehiclePosition.multi_carriage_details)
  return _impl_.multi_carriage_details_;
}

// -------------------------------------------------------------------

// Alert

// repeated .transit_realtime.TimeRange active_period = 1;
inline int Alert::_internal_active_period_size() const {
  return _impl_.active_period_.size();
}
inline int Alert::active_period_size() const {
  return _internal_active_period_size();
}
inline void Alert::clear_active_period() {
  _impl_.active_period_.Clear();
}
inline ::transit_realtime::TimeRange* Alert::mutable_active_period(int index) {
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.active_period)
  return _impl_.active_period_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TimeRange >*
Alert::mutable_active_period() {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.Alert.active_period)
  return &_impl_.active_period_;
}
inline const ::transit_realtime::TimeRange& Alert::_internal_active_period(int index) const {
  return _impl_.active_period_.Get(index);
}
inline const ::transit_realtime::TimeRange& Alert::active_period(int index) const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.active_period)
  return _internal_active_period(index);
}
inline ::transit_realtime::TimeRange* Alert::_internal_add_active_period() {
  return _impl_.active_period_.Add();
}
inline ::transit_realtime::TimeRange* Alert::add_active_period() {
  ::transit_realtime::TimeRange* _add = _internal_add_active_period();
  // @@protoc_insertion_point(field_add:transit_realtime.Alert.active_period)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TimeRange >&
Alert::active_period() const {
  // @@protoc_insertion_point(field_list:transit_realtime.Alert.active_period)
  return _impl_.active_period_;
}

// repeated .transit_realtime.EntitySelector informed_entity = 5;
inline int Alert::_internal_informed_entity_size() const {
  return _impl_.informed_entity_.size();
}
inline int Alert::informed_entity_size() const {
  return _internal_informed_entity_size();
}
inline void Alert::clear_informed_entity() {
  _impl_.informed_entity_.Clear();
}
inline ::transit_realtime::EntitySelector* Alert::mutable_informed_entity(int index) {
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.informed_entity)
  return _impl_.informed_entity_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::EntitySelector >*
Alert::mutable_informed_entity() {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.Alert.informed_entity)
  return &_impl_.informed_entity_;
}
inline const ::transit_realtime::EntitySelector& Alert::_internal_informed_entity(int index) const {
  return _impl_.informed_entity_.Get(index);
}
inline const ::transit_realtime::EntitySelector& Alert::informed_entity(int index) const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.informed_entity)
  return _internal_informed_entity(index);
}
inline ::transit_realtime::EntitySelector* Alert::_internal_add_informed_entity() {
  return _impl_.informed_entity_.Add();
}
inline ::transit_realtime::EntitySelector* Alert::add_informed_entity() {
  ::transit_realtime::EntitySelector* _add = _internal_add_informed_entity();
  // @@protoc_insertion_point(field_add:transit_realtime.Alert.informed_entity)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::EntitySelector >&
Alert::informed_entity() const {
  // @@protoc_insertion_point(field_list:transit_realtime.Alert.informed_entity)
  return _impl_.informed_entity_;
}

// optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];
inline bool Alert::_internal_has_cause() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Alert::has_cause() const {
  return _internal_has_cause();
}
inline void Alert::clear_cause() {
  _impl_.cause_ = 1;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::transit_realtime::Alert_Cause Alert::_internal_cause() const {
  return static_cast< ::transit_realtime::Alert_Cause >(_impl_.cause_);
}
inline ::transit_realtime::Alert_Cause Alert::cause() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.cause)
  return _internal_cause();
}
inline void Alert::_internal_set_cause(::transit_realtime::Alert_Cause value) {
  assert(::transit_realtime::Alert_Cause_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.cause_ = value;
}
inline void Alert::set_cause(::transit_realtime::Alert_Cause value) {
  _internal_set_cause(value);
  // @@protoc_insertion_point(field_set:transit_realtime.Alert.cause)
}

// optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];
inline bool Alert::_internal_has_effect() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Alert::has_effect() const {
  return _internal_has_effect();
}
inline void Alert::clear_effect() {
  _impl_.effect_ = 8;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::transit_realtime::Alert_Effect Alert::_internal_effect() const {
  return static_cast< ::transit_realtime::Alert_Effect >(_impl_.effect_);
}
inline ::transit_realtime::Alert_Effect Alert::effect() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.effect)
  return _internal_effect();
}
inline void Alert::_internal_set_effect(::transit_realtime::Alert_Effect value) {
  assert(::transit_realtime::Alert_Effect_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.effect_ = value;
}
inline void Alert::set_effect(::transit_realtime::Alert_Effect value) {
  _internal_set_effect(value);
  // @@protoc_insertion_point(field_set:transit_realtime.Alert.effect)
}

// optional .transit_realtime.TranslatedString url = 8;
inline bool Alert::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.url_ != nullptr);
  return value;
}
inline bool Alert::has_url() const {
  return _internal_has_url();
}
inline void Alert::clear_url() {
  if (_impl_.url_ != nullptr) _impl_.url_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::transit_realtime::TranslatedString& Alert::_internal_url() const {
  const ::transit_realtime::TranslatedString* p = _impl_.url_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(
      ::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Alert::url() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.url)
  return _internal_url();
}
inline void Alert::unsafe_arena_set_allocated_url(
    ::transit_realtime::TranslatedString* url) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.url_);
  }
  _impl_.url_ = url;
  if (url) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Alert.url)
}
inline ::transit_realtime::TranslatedString* Alert::release_url() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::transit_realtime::TranslatedString* temp = _impl_.url_;
  _impl_.url_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::unsafe_arena_release_url() {
  // @@protoc_insertion_point(field_release:transit_realtime.Alert.url)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::transit_realtime::TranslatedString* temp = _impl_.url_;
  _impl_.url_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.url_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TranslatedString>(GetArenaForAllocation());
    _impl_.url_ = p;
  }
  return _impl_.url_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_url() {
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.url)
  return _msg;
}
inline void Alert::set_allocated_url(::transit_realtime::TranslatedString* url) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.url_;
  }
  if (url) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(url);
    if (message_arena != submessage_arena) {
      url = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, url, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_ = url;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Alert.url)
}

// optional .transit_realtime.TranslatedString header_text = 10;
inline bool Alert::_internal_has_header_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_text_ != nullptr);
  return value;
}
inline bool Alert::has_header_text() const {
  return _internal_has_header_text();
}
inline void Alert::clear_header_text() {
  if (_impl_.header_text_ != nullptr) _impl_.header_text_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::transit_realtime::TranslatedString& Alert::_internal_header_text() const {
  const ::transit_realtime::TranslatedString* p = _impl_.header_text_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(
      ::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Alert::header_text() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.header_text)
  return _internal_header_text();
}
inline void Alert::unsafe_arena_set_allocated_header_text(
    ::transit_realtime::TranslatedString* header_text) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_text_);
  }
  _impl_.header_text_ = header_text;
  if (header_text) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Alert.header_text)
}
inline ::transit_realtime::TranslatedString* Alert::release_header_text() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TranslatedString* temp = _impl_.header_text_;
  _impl_.header_text_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::unsafe_arena_release_header_text() {
  // @@protoc_insertion_point(field_release:transit_realtime.Alert.header_text)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TranslatedString* temp = _impl_.header_text_;
  _impl_.header_text_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::_internal_mutable_header_text() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.header_text_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TranslatedString>(GetArenaForAllocation());
    _impl_.header_text_ = p;
  }
  return _impl_.header_text_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_header_text() {
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_header_text();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.header_text)
  return _msg;
}
inline void Alert::set_allocated_header_text(::transit_realtime::TranslatedString* header_text) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_text_;
  }
  if (header_text) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header_text);
    if (message_arena != submessage_arena) {
      header_text = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header_text, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.header_text_ = header_text;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Alert.header_text)
}

// optional .transit_realtime.TranslatedString description_text = 11;
inline bool Alert::_internal_has_description_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.description_text_ != nullptr);
  return value;
}
inline bool Alert::has_description_text() const {
  return _internal_has_description_text();
}
inline void Alert::clear_description_text() {
  if (_impl_.description_text_ != nullptr) _impl_.description_text_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::transit_realtime::TranslatedString& Alert::_internal_description_text() const {
  const ::transit_realtime::TranslatedString* p = _impl_.description_text_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(
      ::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Alert::description_text() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.description_text)
  return _internal_description_text();
}
inline void Alert::unsafe_arena_set_allocated_description_text(
    ::transit_realtime::TranslatedString* description_text) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.description_text_);
  }
  _impl_.description_text_ = description_text;
  if (description_text) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Alert.description_text)
}
inline ::transit_realtime::TranslatedString* Alert::release_description_text() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::TranslatedString* temp = _impl_.description_text_;
  _impl_.description_text_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::unsafe_arena_release_description_text() {
  // @@protoc_insertion_point(field_release:transit_realtime.Alert.description_text)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::TranslatedString* temp = _impl_.description_text_;
  _impl_.description_text_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::_internal_mutable_description_text() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.description_text_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TranslatedString>(GetArenaForAllocation());
    _impl_.description_text_ = p;
  }
  return _impl_.description_text_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_description_text() {
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_description_text();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.description_text)
  return _msg;
}
inline void Alert::set_allocated_description_text(::transit_realtime::TranslatedString* description_text) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.description_text_;
  }
  if (description_text) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(description_text);
    if (message_arena != submessage_arena) {
      description_text = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, description_text, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.description_text_ = description_text;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Alert.description_text)
}

// optional .transit_realtime.TranslatedString tts_header_text = 12;
inline bool Alert::_internal_has_tts_header_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tts_header_text_ != nullptr);
  return value;
}
inline bool Alert::has_tts_header_text() const {
  return _internal_has_tts_header_text();
}
inline void Alert::clear_tts_header_text() {
  if (_impl_.tts_header_text_ != nullptr) _impl_.tts_header_text_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::transit_realtime::TranslatedString& Alert::_internal_tts_header_text() const {
  const ::transit_realtime::TranslatedString* p = _impl_.tts_header_text_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(
      ::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Alert::tts_header_text() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.tts_header_text)
  return _internal_tts_header_text();
}
inline void Alert::unsafe_arena_set_allocated_tts_header_text(
    ::transit_realtime::TranslatedString* tts_header_text) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tts_header_text_);
  }
  _impl_.tts_header_text_ = tts_header_text;
  if (tts_header_text) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Alert.tts_header_text)
}
inline ::transit_realtime::TranslatedString* Alert::release_tts_header_text() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::TranslatedString* temp = _impl_.tts_header_text_;
  _impl_.tts_header_text_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::unsafe_arena_release_tts_header_text() {
  // @@protoc_insertion_point(field_release:transit_realtime.Alert.tts_header_text)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::TranslatedString* temp = _impl_.tts_header_text_;
  _impl_.tts_header_text_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::_internal_mutable_tts_header_text() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.tts_header_text_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TranslatedString>(GetArenaForAllocation());
    _impl_.tts_header_text_ = p;
  }
  return _impl_.tts_header_text_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_tts_header_text() {
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_tts_header_text();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.tts_header_text)
  return _msg;
}
inline void Alert::set_allocated_tts_header_text(::transit_realtime::TranslatedString* tts_header_text) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tts_header_text_;
  }
  if (tts_header_text) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tts_header_text);
    if (message_arena != submessage_arena) {
      tts_header_text = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tts_header_text, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.tts_header_text_ = tts_header_text;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Alert.tts_header_text)
}

// optional .transit_realtime.TranslatedString tts_description_text = 13;
inline bool Alert::_internal_has_tts_description_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tts_description_text_ != nullptr);
  return value;
}
inline bool Alert::has_tts_description_text() const {
  return _internal_has_tts_description_text();
}
inline void Alert::clear_tts_description_text() {
  if (_impl_.tts_description_text_ != nullptr) _impl_.tts_description_text_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::transit_realtime::TranslatedString& Alert::_internal_tts_description_text() const {
  const ::transit_realtime::TranslatedString* p = _impl_.tts_description_text_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(
      ::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Alert::tts_description_text() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.tts_description_text)
  return _internal_tts_description_text();
}
inline void Alert::unsafe_arena_set_allocated_tts_description_text(
    ::transit_realtime::TranslatedString* tts_description_text) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tts_description_text_);
  }
  _impl_.tts_description_text_ = tts_description_text;
  if (tts_description_text) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Alert.tts_description_text)
}
inline ::transit_realtime::TranslatedString* Alert::release_tts_description_text() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::transit_realtime::TranslatedString* temp = _impl_.tts_description_text_;
  _impl_.tts_description_text_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::unsafe_arena_release_tts_description_text() {
  // @@protoc_insertion_point(field_release:transit_realtime.Alert.tts_description_text)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::transit_realtime::TranslatedString* temp = _impl_.tts_description_text_;
  _impl_.tts_description_text_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::_internal_mutable_tts_description_text() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.tts_description_text_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TranslatedString>(GetArenaForAllocation());
    _impl_.tts_description_text_ = p;
  }
  return _impl_.tts_description_text_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_tts_description_text() {
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_tts_description_text();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.tts_description_text)
  return _msg;
}
inline void Alert::set_allocated_tts_description_text(::transit_realtime::TranslatedString* tts_description_text) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tts_description_text_;
  }
  if (tts_description_text) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tts_description_text);
    if (message_arena != submessage_arena) {
      tts_description_text = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tts_description_text, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.tts_description_text_ = tts_description_text;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Alert.tts_description_text)
}

// optional .transit_realtime.Alert.SeverityLevel severity_level = 14 [default = UNKNOWN_SEVERITY];
inline bool Alert::_internal_has_severity_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Alert::has_severity_level() const {
  return _internal_has_severity_level();
}
inline void Alert::clear_severity_level() {
  _impl_.severity_level_ = 1;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::transit_realtime::Alert_SeverityLevel Alert::_internal_severity_level() const {
  return static_cast< ::transit_realtime::Alert_SeverityLevel >(_impl_.severity_level_);
}
inline ::transit_realtime::Alert_SeverityLevel Alert::severity_level() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.severity_level)
  return _internal_severity_level();
}
inline void Alert::_internal_set_severity_level(::transit_realtime::Alert_SeverityLevel value) {
  assert(::transit_realtime::Alert_SeverityLevel_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.severity_level_ = value;
}
inline void Alert::set_severity_level(::transit_realtime::Alert_SeverityLevel value) {
  _internal_set_severity_level(value);
  // @@protoc_insertion_point(field_set:transit_realtime.Alert.severity_level)
}

// optional .transit_realtime.TranslatedImage image = 15;
inline bool Alert::_internal_has_image() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.image_ != nullptr);
  return value;
}
inline bool Alert::has_image() const {
  return _internal_has_image();
}
inline void Alert::clear_image() {
  if (_impl_.image_ != nullptr) _impl_.image_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::transit_realtime::TranslatedImage& Alert::_internal_image() const {
  const ::transit_realtime::TranslatedImage* p = _impl_.image_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedImage&>(
      ::transit_realtime::_TranslatedImage_default_instance_);
}
inline const ::transit_realtime::TranslatedImage& Alert::image() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.image)
  return _internal_image();
}
inline void Alert::unsafe_arena_set_allocated_image(
    ::transit_realtime::TranslatedImage* image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_);
  }
  _impl_.image_ = image;
  if (image) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Alert.image)
}
inline ::transit_realtime::TranslatedImage* Alert::release_image() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::transit_realtime::TranslatedImage* temp = _impl_.image_;
  _impl_.image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TranslatedImage* Alert::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:transit_realtime.Alert.image)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::transit_realtime::TranslatedImage* temp = _impl_.image_;
  _impl_.image_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedImage* Alert::_internal_mutable_image() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.image_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TranslatedImage>(GetArenaForAllocation());
    _impl_.image_ = p;
  }
  return _impl_.image_;
}
inline ::transit_realtime::TranslatedImage* Alert::mutable_image() {
  ::transit_realtime::TranslatedImage* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.image)
  return _msg;
}
inline void Alert::set_allocated_image(::transit_realtime::TranslatedImage* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.image_;
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image);
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.image_ = image;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Alert.image)
}

// optional .transit_realtime.TranslatedString image_alternative_text = 16;
inline bool Alert::_internal_has_image_alternative_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.image_alternative_text_ != nullptr);
  return value;
}
inline bool Alert::has_image_alternative_text() const {
  return _internal_has_image_alternative_text();
}
inline void Alert::clear_image_alternative_text() {
  if (_impl_.image_alternative_text_ != nullptr) _impl_.image_alternative_text_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::transit_realtime::TranslatedString& Alert::_internal_image_alternative_text() const {
  const ::transit_realtime::TranslatedString* p = _impl_.image_alternative_text_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(
      ::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Alert::image_alternative_text() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.image_alternative_text)
  return _internal_image_alternative_text();
}
inline void Alert::unsafe_arena_set_allocated_image_alternative_text(
    ::transit_realtime::TranslatedString* image_alternative_text) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_alternative_text_);
  }
  _impl_.image_alternative_text_ = image_alternative_text;
  if (image_alternative_text) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Alert.image_alternative_text)
}
inline ::transit_realtime::TranslatedString* Alert::release_image_alternative_text() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::transit_realtime::TranslatedString* temp = _impl_.image_alternative_text_;
  _impl_.image_alternative_text_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::unsafe_arena_release_image_alternative_text() {
  // @@protoc_insertion_point(field_release:transit_realtime.Alert.image_alternative_text)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::transit_realtime::TranslatedString* temp = _impl_.image_alternative_text_;
  _impl_.image_alternative_text_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::_internal_mutable_image_alternative_text() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.image_alternative_text_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TranslatedString>(GetArenaForAllocation());
    _impl_.image_alternative_text_ = p;
  }
  return _impl_.image_alternative_text_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_image_alternative_text() {
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_image_alternative_text();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.image_alternative_text)
  return _msg;
}
inline void Alert::set_allocated_image_alternative_text(::transit_realtime::TranslatedString* image_alternative_text) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.image_alternative_text_;
  }
  if (image_alternative_text) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image_alternative_text);
    if (message_arena != submessage_arena) {
      image_alternative_text = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image_alternative_text, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.image_alternative_text_ = image_alternative_text;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Alert.image_alternative_text)
}

// -------------------------------------------------------------------

// TimeRange

// optional uint64 start = 1;
inline bool TimeRange::_internal_has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TimeRange::has_start() const {
  return _internal_has_start();
}
inline void TimeRange::clear_start() {
  _impl_.start_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t TimeRange::_internal_start() const {
  return _impl_.start_;
}
inline uint64_t TimeRange::start() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TimeRange.start)
  return _internal_start();
}
inline void TimeRange::_internal_set_start(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.start_ = value;
}
inline void TimeRange::set_start(uint64_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TimeRange.start)
}

// optional uint64 end = 2;
inline bool TimeRange::_internal_has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TimeRange::has_end() const {
  return _internal_has_end();
}
inline void TimeRange::clear_end() {
  _impl_.end_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t TimeRange::_internal_end() const {
  return _impl_.end_;
}
inline uint64_t TimeRange::end() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TimeRange.end)
  return _internal_end();
}
inline void TimeRange::_internal_set_end(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.end_ = value;
}
inline void TimeRange::set_end(uint64_t value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TimeRange.end)
}

// -------------------------------------------------------------------

// Position

// required float latitude = 1;
inline bool Position::_internal_has_latitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Position::has_latitude() const {
  return _internal_has_latitude();
}
inline void Position::clear_latitude() {
  _impl_.latitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Position::_internal_latitude() const {
  return _impl_.latitude_;
}
inline float Position::latitude() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Position.latitude)
  return _internal_latitude();
}
inline void Position::_internal_set_latitude(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.latitude_ = value;
}
inline void Position::set_latitude(float value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:transit_realtime.Position.latitude)
}

// required float longitude = 2;
inline bool Position::_internal_has_longitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Position::has_longitude() const {
  return _internal_has_longitude();
}
inline void Position::clear_longitude() {
  _impl_.longitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Position::_internal_longitude() const {
  return _impl_.longitude_;
}
inline float Position::longitude() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Position.longitude)
  return _internal_longitude();
}
inline void Position::_internal_set_longitude(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.longitude_ = value;
}
inline void Position::set_longitude(float value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:transit_realtime.Position.longitude)
}

// optional float bearing = 3;
inline bool Position::_internal_has_bearing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Position::has_bearing() const {
  return _internal_has_bearing();
}
inline void Position::clear_bearing() {
  _impl_.bearing_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float Position::_internal_bearing() const {
  return _impl_.bearing_;
}
inline float Position::bearing() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Position.bearing)
  return _internal_bearing();
}
inline void Position::_internal_set_bearing(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.bearing_ = value;
}
inline void Position::set_bearing(float value) {
  _internal_set_bearing(value);
  // @@protoc_insertion_point(field_set:transit_realtime.Position.bearing)
}

// optional double odometer = 4;
inline bool Position::_internal_has_odometer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Position::has_odometer() const {
  return _internal_has_odometer();
}
inline void Position::clear_odometer() {
  _impl_.odometer_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Position::_internal_odometer() const {
  return _impl_.odometer_;
}
inline double Position::odometer() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Position.odometer)
  return _internal_odometer();
}
inline void Position::_internal_set_odometer(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.odometer_ = value;
}
inline void Position::set_odometer(double value) {
  _internal_set_odometer(value);
  // @@protoc_insertion_point(field_set:transit_realtime.Position.odometer)
}

// optional float speed = 5;
inline bool Position::_internal_has_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Position::has_speed() const {
  return _internal_has_speed();
}
inline void Position::clear_speed() {
  _impl_.speed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Position::_internal_speed() const {
  return _impl_.speed_;
}
inline float Position::speed() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Position.speed)
  return _internal_speed();
}
inline void Position::_internal_set_speed(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.speed_ = value;
}
inline void Position::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:transit_realtime.Position.speed)
}

// -------------------------------------------------------------------

// TripDescriptor

// optional string trip_id = 1;
inline bool TripDescriptor::_internal_has_trip_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TripDescriptor::has_trip_id() const {
  return _internal_has_trip_id();
}
inline void TripDescriptor::clear_trip_id() {
  _impl_.trip_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TripDescriptor::trip_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.trip_id)
  return _internal_trip_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripDescriptor::set_trip_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.trip_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.trip_id)
}
inline std::string* TripDescriptor::mutable_trip_id() {
  std::string* _s = _internal_mutable_trip_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripDescriptor.trip_id)
  return _s;
}
inline const std::string& TripDescriptor::_internal_trip_id() const {
  return _impl_.trip_id_.Get();
}
inline void TripDescriptor::_internal_set_trip_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.trip_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TripDescriptor::_internal_mutable_trip_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.trip_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TripDescriptor::release_trip_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripDescriptor.trip_id)
  if (!_internal_has_trip_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.trip_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trip_id_.IsDefault()) {
    _impl_.trip_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TripDescriptor::set_allocated_trip_id(std::string* trip_id) {
  if (trip_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.trip_id_.SetAllocated(trip_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trip_id_.IsDefault()) {
    _impl_.trip_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripDescriptor.trip_id)
}

// optional string route_id = 5;
inline bool TripDescriptor::_internal_has_route_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TripDescriptor::has_route_id() const {
  return _internal_has_route_id();
}
inline void TripDescriptor::clear_route_id() {
  _impl_.route_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TripDescriptor::route_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.route_id)
  return _internal_route_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripDescriptor::set_route_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.route_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.route_id)
}
inline std::string* TripDescriptor::mutable_route_id() {
  std::string* _s = _internal_mutable_route_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripDescriptor.route_id)
  return _s;
}
inline const std::string& TripDescriptor::_internal_route_id() const {
  return _impl_.route_id_.Get();
}
inline void TripDescriptor::_internal_set_route_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.route_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TripDescriptor::_internal_mutable_route_id() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.route_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TripDescriptor::release_route_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripDescriptor.route_id)
  if (!_internal_has_route_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.route_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.route_id_.IsDefault()) {
    _impl_.route_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TripDescriptor::set_allocated_route_id(std::string* route_id) {
  if (route_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.route_id_.SetAllocated(route_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.route_id_.IsDefault()) {
    _impl_.route_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripDescriptor.route_id)
}

// optional uint32 direction_id = 6;
inline bool TripDescriptor::_internal_has_direction_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TripDescriptor::has_direction_id() const {
  return _internal_has_direction_id();
}
inline void TripDescriptor::clear_direction_id() {
  _impl_.direction_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t TripDescriptor::_internal_direction_id() const {
  return _impl_.direction_id_;
}
inline uint32_t TripDescriptor::direction_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.direction_id)
  return _internal_direction_id();
}
inline void TripDescriptor::_internal_set_direction_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.direction_id_ = value;
}
inline void TripDescriptor::set_direction_id(uint32_t value) {
  _internal_set_direction_id(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.direction_id)
}

// optional string start_time = 2;
inline bool TripDescriptor::_internal_has_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TripDescriptor::has_start_time() const {
  return _internal_has_start_time();
}
inline void TripDescriptor::clear_start_time() {
  _impl_.start_time_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TripDescriptor::start_time() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.start_time)
  return _internal_start_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripDescriptor::set_start_time(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.start_time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.start_time)
}
inline std::string* TripDescriptor::mutable_start_time() {
  std::string* _s = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripDescriptor.start_time)
  return _s;
}
inline const std::string& TripDescriptor::_internal_start_time() const {
  return _impl_.start_time_.Get();
}
inline void TripDescriptor::_internal_set_start_time(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.start_time_.Set(value, GetArenaForAllocation());
}
inline std::string* TripDescriptor::_internal_mutable_start_time() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.start_time_.Mutable(GetArenaForAllocation());
}
inline std::string* TripDescriptor::release_start_time() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripDescriptor.start_time)
  if (!_internal_has_start_time()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.start_time_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.start_time_.IsDefault()) {
    _impl_.start_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TripDescriptor::set_allocated_start_time(std::string* start_time) {
  if (start_time != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.start_time_.SetAllocated(start_time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.start_time_.IsDefault()) {
    _impl_.start_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripDescriptor.start_time)
}

// optional string start_date = 3;
inline bool TripDescriptor::_internal_has_start_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TripDescriptor::has_start_date() const {
  return _internal_has_start_date();
}
inline void TripDescriptor::clear_start_date() {
  _impl_.start_date_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TripDescriptor::start_date() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.start_date)
  return _internal_start_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TripDescriptor::set_start_date(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.start_date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.start_date)
}
inline std::string* TripDescriptor::mutable_start_date() {
  std::string* _s = _internal_mutable_start_date();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripDescriptor.start_date)
  return _s;
}
inline const std::string& TripDescriptor::_internal_start_date() const {
  return _impl_.start_date_.Get();
}
inline void TripDescriptor::_internal_set_start_date(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.start_date_.Set(value, GetArenaForAllocation());
}
inline std::string* TripDescriptor::_internal_mutable_start_date() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.start_date_.Mutable(GetArenaForAllocation());
}
inline std::string* TripDescriptor::release_start_date() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripDescriptor.start_date)
  if (!_internal_has_start_date()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.start_date_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.start_date_.IsDefault()) {
    _impl_.start_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TripDescriptor::set_allocated_start_date(std::string* start_date) {
  if (start_date != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.start_date_.SetAllocated(start_date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.start_date_.IsDefault()) {
    _impl_.start_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripDescriptor.start_date)
}

// optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;
inline bool TripDescriptor::_internal_has_schedule_relationship() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TripDescriptor::has_schedule_relationship() const {
  return _internal_has_schedule_relationship();
}
inline void TripDescriptor::clear_schedule_relationship() {
  _impl_.schedule_relationship_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::transit_realtime::TripDescriptor_ScheduleRelationship TripDescriptor::_internal_schedule_relationship() const {
  return static_cast< ::transit_realtime::TripDescriptor_ScheduleRelationship >(_impl_.schedule_relationship_);
}
inline ::transit_realtime::TripDescriptor_ScheduleRelationship TripDescriptor::schedule_relationship() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.schedule_relationship)
  return _internal_schedule_relationship();
}
inline void TripDescriptor::_internal_set_schedule_relationship(::transit_realtime::TripDescriptor_ScheduleRelationship value) {
  assert(::transit_realtime::TripDescriptor_ScheduleRelationship_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.schedule_relationship_ = value;
}
inline void TripDescriptor::set_schedule_relationship(::transit_realtime::TripDescriptor_ScheduleRelationship value) {
  _internal_set_schedule_relationship(value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.schedule_relationship)
}

// -------------------------------------------------------------------

// VehicleDescriptor

// optional string id = 1;
inline bool VehicleDescriptor::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VehicleDescriptor::has_id() const {
  return _internal_has_id();
}
inline void VehicleDescriptor::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VehicleDescriptor::id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehicleDescriptor.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VehicleDescriptor::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.VehicleDescriptor.id)
}
inline std::string* VehicleDescriptor::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehicleDescriptor.id)
  return _s;
}
inline const std::string& VehicleDescriptor::_internal_id() const {
  return _impl_.id_.Get();
}
inline void VehicleDescriptor::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* VehicleDescriptor::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* VehicleDescriptor::release_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehicleDescriptor.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VehicleDescriptor::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehicleDescriptor.id)
}

// optional string label = 2;
inline bool VehicleDescriptor::_internal_has_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VehicleDescriptor::has_label() const {
  return _internal_has_label();
}
inline void VehicleDescriptor::clear_label() {
  _impl_.label_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VehicleDescriptor::label() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehicleDescriptor.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VehicleDescriptor::set_label(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.VehicleDescriptor.label)
}
inline std::string* VehicleDescriptor::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehicleDescriptor.label)
  return _s;
}
inline const std::string& VehicleDescriptor::_internal_label() const {
  return _impl_.label_.Get();
}
inline void VehicleDescriptor::_internal_set_label(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* VehicleDescriptor::_internal_mutable_label() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.label_.Mutable(GetArenaForAllocation());
}
inline std::string* VehicleDescriptor::release_label() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehicleDescriptor.label)
  if (!_internal_has_label()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.label_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VehicleDescriptor::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehicleDescriptor.label)
}

// optional string license_plate = 3;
inline bool VehicleDescriptor::_internal_has_license_plate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VehicleDescriptor::has_license_plate() const {
  return _internal_has_license_plate();
}
inline void VehicleDescriptor::clear_license_plate() {
  _impl_.license_plate_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& VehicleDescriptor::license_plate() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehicleDescriptor.license_plate)
  return _internal_license_plate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VehicleDescriptor::set_license_plate(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.license_plate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.VehicleDescriptor.license_plate)
}
inline std::string* VehicleDescriptor::mutable_license_plate() {
  std::string* _s = _internal_mutable_license_plate();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehicleDescriptor.license_plate)
  return _s;
}
inline const std::string& VehicleDescriptor::_internal_license_plate() const {
  return _impl_.license_plate_.Get();
}
inline void VehicleDescriptor::_internal_set_license_plate(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.license_plate_.Set(value, GetArenaForAllocation());
}
inline std::string* VehicleDescriptor::_internal_mutable_license_plate() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.license_plate_.Mutable(GetArenaForAllocation());
}
inline std::string* VehicleDescriptor::release_license_plate() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehicleDescriptor.license_plate)
  if (!_internal_has_license_plate()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.license_plate_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.license_plate_.IsDefault()) {
    _impl_.license_plate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VehicleDescriptor::set_allocated_license_plate(std::string* license_plate) {
  if (license_plate != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.license_plate_.SetAllocated(license_plate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.license_plate_.IsDefault()) {
    _impl_.license_plate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehicleDescriptor.license_plate)
}

// -------------------------------------------------------------------

// EntitySelector

// optional string agency_id = 1;
inline bool EntitySelector::_internal_has_agency_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EntitySelector::has_agency_id() const {
  return _internal_has_agency_id();
}
inline void EntitySelector::clear_agency_id() {
  _impl_.agency_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EntitySelector::agency_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.EntitySelector.agency_id)
  return _internal_agency_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EntitySelector::set_agency_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.agency_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.EntitySelector.agency_id)
}
inline std::string* EntitySelector::mutable_agency_id() {
  std::string* _s = _internal_mutable_agency_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.EntitySelector.agency_id)
  return _s;
}
inline const std::string& EntitySelector::_internal_agency_id() const {
  return _impl_.agency_id_.Get();
}
inline void EntitySelector::_internal_set_agency_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.agency_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EntitySelector::_internal_mutable_agency_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.agency_id_.Mutable(GetArenaForAllocation());
}
inline std::string* EntitySelector::release_agency_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.EntitySelector.agency_id)
  if (!_internal_has_agency_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.agency_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.agency_id_.IsDefault()) {
    _impl_.agency_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EntitySelector::set_allocated_agency_id(std::string* agency_id) {
  if (agency_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.agency_id_.SetAllocated(agency_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.agency_id_.IsDefault()) {
    _impl_.agency_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.EntitySelector.agency_id)
}

// optional string route_id = 2;
inline bool EntitySelector::_internal_has_route_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EntitySelector::has_route_id() const {
  return _internal_has_route_id();
}
inline void EntitySelector::clear_route_id() {
  _impl_.route_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& EntitySelector::route_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.EntitySelector.route_id)
  return _internal_route_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EntitySelector::set_route_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.route_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.EntitySelector.route_id)
}
inline std::string* EntitySelector::mutable_route_id() {
  std::string* _s = _internal_mutable_route_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.EntitySelector.route_id)
  return _s;
}
inline const std::string& EntitySelector::_internal_route_id() const {
  return _impl_.route_id_.Get();
}
inline void EntitySelector::_internal_set_route_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.route_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EntitySelector::_internal_mutable_route_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.route_id_.Mutable(GetArenaForAllocation());
}
inline std::string* EntitySelector::release_route_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.EntitySelector.route_id)
  if (!_internal_has_route_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.route_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.route_id_.IsDefault()) {
    _impl_.route_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EntitySelector::set_allocated_route_id(std::string* route_id) {
  if (route_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.route_id_.SetAllocated(route_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.route_id_.IsDefault()) {
    _impl_.route_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.EntitySelector.route_id)
}

// optional int32 route_type = 3;
inline bool EntitySelector::_internal_has_route_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool EntitySelector::has_route_type() const {
  return _internal_has_route_type();
}
inline void EntitySelector::clear_route_type() {
  _impl_.route_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t EntitySelector::_internal_route_type() const {
  return _impl_.route_type_;
}
inline int32_t EntitySelector::route_type() const {
  // @@protoc_insertion_point(field_get:transit_realtime.EntitySelector.route_type)
  return _internal_route_type();
}
inline void EntitySelector::_internal_set_route_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.route_type_ = value;
}
inline void EntitySelector::set_route_type(int32_t value) {
  _internal_set_route_type(value);
  // @@protoc_insertion_point(field_set:transit_realtime.EntitySelector.route_type)
}

// optional .transit_realtime.TripDescriptor trip = 4;
inline bool EntitySelector::_internal_has_trip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trip_ != nullptr);
  return value;
}
inline bool EntitySelector::has_trip() const {
  return _internal_has_trip();
}
inline void EntitySelector::clear_trip() {
  if (_impl_.trip_ != nullptr) _impl_.trip_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::transit_realtime::TripDescriptor& EntitySelector::_internal_trip() const {
  const ::transit_realtime::TripDescriptor* p = _impl_.trip_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripDescriptor&>(
      ::transit_realtime::_TripDescriptor_default_instance_);
}
inline const ::transit_realtime::TripDescriptor& EntitySelector::trip() const {
  // @@protoc_insertion_point(field_get:transit_realtime.EntitySelector.trip)
  return _internal_trip();
}
inline void EntitySelector::unsafe_arena_set_allocated_trip(
    ::transit_realtime::TripDescriptor* trip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trip_);
  }
  _impl_.trip_ = trip;
  if (trip) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.EntitySelector.trip)
}
inline ::transit_realtime::TripDescriptor* EntitySelector::release_trip() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::TripDescriptor* temp = _impl_.trip_;
  _impl_.trip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::transit_realtime::TripDescriptor* EntitySelector::unsafe_arena_release_trip() {
  // @@protoc_insertion_point(field_release:transit_realtime.EntitySelector.trip)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::TripDescriptor* temp = _impl_.trip_;
  _impl_.trip_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripDescriptor* EntitySelector::_internal_mutable_trip() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.trip_ == nullptr) {
    auto* p = CreateMaybeMessage<::transit_realtime::TripDescriptor>(GetArenaForAllocation());
    _impl_.trip_ = p;
  }
  return _impl_.trip_;
}
inline ::transit_realtime::TripDescriptor* EntitySelector::mutable_trip() {
  ::transit_realtime::TripDescriptor* _msg = _internal_mutable_trip();
  // @@protoc_insertion_point(field_mutable:transit_realtime.EntitySelector.trip)
  return _msg;
}
inline void EntitySelector::set_allocated_trip(::transit_realtime::TripDescriptor* trip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trip_;
  }
  if (trip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trip);
    if (message_arena != submessage_arena) {
      trip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trip, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.trip_ = trip;
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.EntitySelector.trip)
}

// optional string stop_id = 5;
inline bool EntitySelector::_internal_has_stop_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EntitySelector::has_stop_id() const {
  return _internal_has_stop_id();
}
inline void EntitySelector::clear_stop_id() {
  _impl_.stop_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& EntitySelector::stop_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.EntitySelector.stop_id)
  return _internal_stop_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EntitySelector::set_stop_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.stop_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.EntitySelector.stop_id)
}
inline std::string* EntitySelector::mutable_stop_id() {
  std::string* _s = _internal_mutable_stop_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.EntitySelector.stop_id)
  return _s;
}
inline const std::string& EntitySelector::_internal_stop_id() const {
  return _impl_.stop_id_.Get();
}
inline void EntitySelector::_internal_set_stop_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.stop_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EntitySelector::_internal_mutable_stop_id() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.stop_id_.Mutable(GetArenaForAllocation());
}
inline std::string* EntitySelector::release_stop_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.EntitySelector.stop_id)
  if (!_internal_has_stop_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.stop_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stop_id_.IsDefault()) {
    _impl_.stop_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EntitySelector::set_allocated_stop_id(std::string* stop_id) {
  if (stop_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.stop_id_.SetAllocated(stop_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stop_id_.IsDefault()) {
    _impl_.stop_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.EntitySelector.stop_id)
}

// optional uint32 direction_id = 6;
inline bool EntitySelector::_internal_has_direction_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool EntitySelector::has_direction_id() const {
  return _internal_has_direction_id();
}
inline void EntitySelector::clear_direction_id() {
  _impl_.direction_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t EntitySelector::_internal_direction_id() const {
  return _impl_.direction_id_;
}
inline uint32_t EntitySelector::direction_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.EntitySelector.direction_id)
  return _internal_direction_id();
}
inline void EntitySelector::_internal_set_direction_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.direction_id_ = value;
}
inline void EntitySelector::set_direction_id(uint32_t value) {
  _internal_set_direction_id(value);
  // @@protoc_insertion_point(field_set:transit_realtime.EntitySelector.direction_id)
}

// -------------------------------------------------------------------

// TranslatedString_Translation

// required string text = 1;
inline bool TranslatedString_Translation::_internal_has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TranslatedString_Translation::has_text() const {
  return _internal_has_text();
}
inline void TranslatedString_Translation::clear_text() {
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TranslatedString_Translation::text() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TranslatedString.Translation.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranslatedString_Translation::set_text(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.TranslatedString.Translation.text)
}
inline std::string* TranslatedString_Translation::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TranslatedString.Translation.text)
  return _s;
}
inline const std::string& TranslatedString_Translation::_internal_text() const {
  return _impl_.text_.Get();
}
inline void TranslatedString_Translation::_internal_set_text(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TranslatedString_Translation::_internal_mutable_text() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* TranslatedString_Translation::release_text() {
  // @@protoc_insertion_point(field_release:transit_realtime.TranslatedString.Translation.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TranslatedString_Translation::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TranslatedString.Translation.text)
}

// optional string language = 2;
inline bool TranslatedString_Translation::_internal_has_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TranslatedString_Translation::has_language() const {
  return _internal_has_language();
}
inline void TranslatedString_Translation::clear_language() {
  _impl_.language_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TranslatedString_Translation::language() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TranslatedString.Translation.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranslatedString_Translation::set_language(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.TranslatedString.Translation.language)
}
inline std::string* TranslatedString_Translation::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TranslatedString.Translation.language)
  return _s;
}
inline const std::string& TranslatedString_Translation::_internal_language() const {
  return _impl_.language_.Get();
}
inline void TranslatedString_Translation::_internal_set_language(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* TranslatedString_Translation::_internal_mutable_language() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* TranslatedString_Translation::release_language() {
  // @@protoc_insertion_point(field_release:transit_realtime.TranslatedString.Translation.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.language_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TranslatedString_Translation::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TranslatedString.Translation.language)
}

// -------------------------------------------------------------------

// TranslatedString

// repeated .transit_realtime.TranslatedString.Translation translation = 1;
inline int TranslatedString::_internal_translation_size() const {
  return _impl_.translation_.size();
}
inline int TranslatedString::translation_size() const {
  return _internal_translation_size();
}
inline void TranslatedString::clear_translation() {
  _impl_.translation_.Clear();
}
inline ::transit_realtime::TranslatedString_Translation* TranslatedString::mutable_translation(int index) {
  // @@protoc_insertion_point(field_mutable:transit_realtime.TranslatedString.translation)
  return _impl_.translation_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation >*
TranslatedString::mutable_translation() {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.TranslatedString.translation)
  return &_impl_.translation_;
}
inline const ::transit_realtime::TranslatedString_Translation& TranslatedString::_internal_translation(int index) const {
  return _impl_.translation_.Get(index);
}
inline const ::transit_realtime::TranslatedString_Translation& TranslatedString::translation(int index) const {
  // @@protoc_insertion_point(field_get:transit_realtime.TranslatedString.translation)
  return _internal_translation(index);
}
inline ::transit_realtime::TranslatedString_Translation* TranslatedString::_internal_add_translation() {
  return _impl_.translation_.Add();
}
inline ::transit_realtime::TranslatedString_Translation* TranslatedString::add_translation() {
  ::transit_realtime::TranslatedString_Translation* _add = _internal_add_translation();
  // @@protoc_insertion_point(field_add:transit_realtime.TranslatedString.translation)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation >&
TranslatedString::translation() const {
  // @@protoc_insertion_point(field_list:transit_realtime.TranslatedString.translation)
  return _impl_.translation_;
}

// -------------------------------------------------------------------

// TranslatedImage_LocalizedImage

// required string url = 1;
inline bool TranslatedImage_LocalizedImage::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TranslatedImage_LocalizedImage::has_url() const {
  return _internal_has_url();
}
inline void TranslatedImage_LocalizedImage::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TranslatedImage_LocalizedImage::url() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TranslatedImage.LocalizedImage.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranslatedImage_LocalizedImage::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.TranslatedImage.LocalizedImage.url)
}
inline std::string* TranslatedImage_LocalizedImage::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TranslatedImage.LocalizedImage.url)
  return _s;
}
inline const std::string& TranslatedImage_LocalizedImage::_internal_url() const {
  return _impl_.url_.Get();
}
inline void TranslatedImage_LocalizedImage::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* TranslatedImage_LocalizedImage::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* TranslatedImage_LocalizedImage::release_url() {
  // @@protoc_insertion_point(field_release:transit_realtime.TranslatedImage.LocalizedImage.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TranslatedImage_LocalizedImage::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TranslatedImage.LocalizedImage.url)
}

// required string media_type = 2;
inline bool TranslatedImage_LocalizedImage::_internal_has_media_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TranslatedImage_LocalizedImage::has_media_type() const {
  return _internal_has_media_type();
}
inline void TranslatedImage_LocalizedImage::clear_media_type() {
  _impl_.media_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TranslatedImage_LocalizedImage::media_type() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TranslatedImage.LocalizedImage.media_type)
  return _internal_media_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranslatedImage_LocalizedImage::set_media_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.media_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.TranslatedImage.LocalizedImage.media_type)
}
inline std::string* TranslatedImage_LocalizedImage::mutable_media_type() {
  std::string* _s = _internal_mutable_media_type();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TranslatedImage.LocalizedImage.media_type)
  return _s;
}
inline const std::string& TranslatedImage_LocalizedImage::_internal_media_type() const {
  return _impl_.media_type_.Get();
}
inline void TranslatedImage_LocalizedImage::_internal_set_media_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.media_type_.Set(value, GetArenaForAllocation());
}
inline std::string* TranslatedImage_LocalizedImage::_internal_mutable_media_type() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.media_type_.Mutable(GetArenaForAllocation());
}
inline std::string* TranslatedImage_LocalizedImage::release_media_type() {
  // @@protoc_insertion_point(field_release:transit_realtime.TranslatedImage.LocalizedImage.media_type)
  if (!_internal_has_media_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.media_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.media_type_.IsDefault()) {
    _impl_.media_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TranslatedImage_LocalizedImage::set_allocated_media_type(std::string* media_type) {
  if (media_type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.media_type_.SetAllocated(media_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.media_type_.IsDefault()) {
    _impl_.media_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TranslatedImage.LocalizedImage.media_type)
}

// optional string language = 3;
inline bool TranslatedImage_LocalizedImage::_internal_has_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TranslatedImage_LocalizedImage::has_language() const {
  return _internal_has_language();
}
inline void TranslatedImage_LocalizedImage::clear_language() {
  _impl_.language_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TranslatedImage_LocalizedImage::language() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TranslatedImage.LocalizedImage.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranslatedImage_LocalizedImage::set_language(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.TranslatedImage.LocalizedImage.language)
}
inline std::string* TranslatedImage_LocalizedImage::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TranslatedImage.LocalizedImage.language)
  return _s;
}
inline const std::string& TranslatedImage_LocalizedImage::_internal_language() const {
  return _impl_.language_.Get();
}
inline void TranslatedImage_LocalizedImage::_internal_set_language(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* TranslatedImage_LocalizedImage::_internal_mutable_language() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* TranslatedImage_LocalizedImage::release_language() {
  // @@protoc_insertion_point(field_release:transit_realtime.TranslatedImage.LocalizedImage.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.language_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TranslatedImage_LocalizedImage::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TranslatedImage.LocalizedImage.language)
}

// -------------------------------------------------------------------

// TranslatedImage

// repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;
inline int TranslatedImage::_internal_localized_image_size() const {
  return _impl_.localized_image_.size();
}
inline int TranslatedImage::localized_image_size() const {
  return _internal_localized_image_size();
}
inline void TranslatedImage::clear_localized_image() {
  _impl_.localized_image_.Clear();
}
inline ::transit_realtime::TranslatedImage_LocalizedImage* TranslatedImage::mutable_localized_image(int index) {
  // @@protoc_insertion_point(field_mutable:transit_realtime.TranslatedImage.localized_image)
  return _impl_.localized_image_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TranslatedImage_LocalizedImage >*
TranslatedImage::mutable_localized_image() {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.TranslatedImage.localized_image)
  return &_impl_.localized_image_;
}
inline const ::transit_realtime::TranslatedImage_LocalizedImage& TranslatedImage::_internal_localized_image(int index) const {
  return _impl_.localized_image_.Get(index);
}
inline const ::transit_realtime::TranslatedImage_LocalizedImage& TranslatedImage::localized_image(int index) const {
  // @@protoc_insertion_point(field_get:transit_realtime.TranslatedImage.localized_image)
  return _internal_localized_image(index);
}
inline ::transit_realtime::TranslatedImage_LocalizedImage* TranslatedImage::_internal_add_localized_image() {
  return _impl_.localized_image_.Add();
}
inline ::transit_realtime::TranslatedImage_LocalizedImage* TranslatedImage::add_localized_image() {
  ::transit_realtime::TranslatedImage_LocalizedImage* _add = _internal_add_localized_image();
  // @@protoc_insertion_point(field_add:transit_realtime.TranslatedImage.localized_image)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::transit_realtime::TranslatedImage_LocalizedImage >&
TranslatedImage::localized_image() const {
  // @@protoc_insertion_point(field_list:transit_realtime.TranslatedImage.localized_image)
  return _impl_.localized_image_;
}

// -------------------------------------------------------------------

// Shape

// optional string shape_id = 1;
inline bool Shape::_internal_has_shape_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Shape::has_shape_id() const {
  return _internal_has_shape_id();
}
inline void Shape::clear_shape_id() {
  _impl_.shape_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Shape::shape_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Shape.shape_id)
  return _internal_shape_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Shape::set_shape_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.shape_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.Shape.shape_id)
}
inline std::string* Shape::mutable_shape_id() {
  std::string* _s = _internal_mutable_shape_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Shape.shape_id)
  return _s;
}
inline const std::string& Shape::_internal_shape_id() const {
  return _impl_.shape_id_.Get();
}
inline void Shape::_internal_set_shape_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.shape_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Shape::_internal_mutable_shape_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.shape_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Shape::release_shape_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.Shape.shape_id)
  if (!_internal_has_shape_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.shape_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.shape_id_.IsDefault()) {
    _impl_.shape_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Shape::set_allocated_shape_id(std::string* shape_id) {
  if (shape_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.shape_id_.SetAllocated(shape_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.shape_id_.IsDefault()) {
    _impl_.shape_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Shape.shape_id)
}

// optional string encoded_polyline = 2;
inline bool Shape::_internal_has_encoded_polyline() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Shape::has_encoded_polyline() const {
  return _internal_has_encoded_polyline();
}
inline void Shape::clear_encoded_polyline() {
  _impl_.encoded_polyline_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Shape::encoded_polyline() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Shape.encoded_polyline)
  return _internal_encoded_polyline();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Shape::set_encoded_polyline(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.encoded_polyline_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transit_realtime.Shape.encoded_polyline)
}
inline std::string* Shape::mutable_encoded_polyline() {
  std::string* _s = _internal_mutable_encoded_polyline();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Shape.encoded_polyline)
  return _s;
}
inline const std::string& Shape::_internal_encoded_polyline() const {
  return _impl_.encoded_polyline_.Get();
}
inline void Shape::_internal_set_encoded_polyline(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.encoded_polyline_.Set(value, GetArenaForAllocation());
}
inline std::string* Shape::_internal_mutable_encoded_polyline() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.encoded_polyline_.Mutable(GetArenaForAllocation());
}
inline std::string* Shape::release_encoded_polyline() {
  // @@protoc_insertion_point(field_release:transit_realtime.Shape.encoded_polyline)
  if (!_internal_has_encoded_polyline()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.encoded_polyline_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.encoded_polyline_.IsDefault()) {
    _impl_.encoded_polyline_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Shape::set_allocated_encoded_polyline(std::string* encoded_polyline) {
  if (encoded_polyline != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.encoded_polyline_.SetAllocated(encoded_polyline, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.encoded_polyline_.IsDefault()) {
    _impl_.encoded_polyline_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Shape.encoded_polyline)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace transit_realtime

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::transit_realtime::FeedHeader_Incrementality> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::FeedHeader_Incrementality>() {
  return ::transit_realtime::FeedHeader_Incrementality_descriptor();
}
template <> struct is_proto_enum< ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship>() {
  return ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor();
}
template <> struct is_proto_enum< ::transit_realtime::VehiclePosition_VehicleStopStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::VehiclePosition_VehicleStopStatus>() {
  return ::transit_realtime::VehiclePosition_VehicleStopStatus_descriptor();
}
template <> struct is_proto_enum< ::transit_realtime::VehiclePosition_CongestionLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::VehiclePosition_CongestionLevel>() {
  return ::transit_realtime::VehiclePosition_CongestionLevel_descriptor();
}
template <> struct is_proto_enum< ::transit_realtime::VehiclePosition_OccupancyStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::VehiclePosition_OccupancyStatus>() {
  return ::transit_realtime::VehiclePosition_OccupancyStatus_descriptor();
}
template <> struct is_proto_enum< ::transit_realtime::Alert_Cause> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::Alert_Cause>() {
  return ::transit_realtime::Alert_Cause_descriptor();
}
template <> struct is_proto_enum< ::transit_realtime::Alert_Effect> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::Alert_Effect>() {
  return ::transit_realtime::Alert_Effect_descriptor();
}
template <> struct is_proto_enum< ::transit_realtime::Alert_SeverityLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::Alert_SeverityLevel>() {
  return ::transit_realtime::Alert_SeverityLevel_descriptor();
}
template <> struct is_proto_enum< ::transit_realtime::TripDescriptor_ScheduleRelationship> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::TripDescriptor_ScheduleRelationship>() {
  return ::transit_realtime::TripDescriptor_ScheduleRelationship_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_gtfs_2drealtime_2eproto
